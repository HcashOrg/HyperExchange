#include <stdio.h>
#include <graphene/crosschain/crosschain_interface_eth.hpp>
#include <fc/network/ip.hpp>
#include <fc/network/tcp_socket.hpp>
#include <fc/io/json.hpp>
#include <fc/variant.hpp>
#include <fc/variant_object.hpp>
#include <iostream>
#include <graphene/crosschain_privatekey_management/private_key.hpp>

#include <libethcore/TransactionBase.h>
#include <libethcore/Common.h>
#include <libethcore/CommonJS.h>
#include <libdevcrypto/DevCryptoCommon.h>
#include <libdevcore/CommonData.h>

/*

#include <libethcore/TransactionBase.h>
#include <libethcore/Common.h>
#include <libethcore/CommonJS.h>
#include <libdevcrypto/DevCryptoCommon.h>
#include <libdevcore/CommonData.h>
*/

namespace graphene {
	namespace crosschain {
		std::string to_hex(const char* d, uint32_t s)
		{
			std::string r;
			const char* to_hex = "0123456789abcdef";
			uint8_t* c = (uint8_t*)d;
			for (uint32_t i = 0; i < s; ++i)
				(r += to_hex[(c[i] >> 4)]) += to_hex[(c[i] & 0x0f)];
			return r;
		}
		std::string to_hex(const std::vector<char>& data)
		{
			if (data.size())
				return to_hex(data.data(), data.size());
			return "";
		}
		const std::string TurnFromEthAmount(const std::string& source, const int& precision) {
			std::string ret;
			if (source.size() <= precision) {
				ret += "0.";
				for (size_t i = 0; i < precision - source.size(); i++) {
					ret += '0';
				}
				size_t amount_pos = 0;
				for (size_t i = source.size() - 1; i > 0; i--) {
					if (source[i] == '0') {
						continue;
					}
					amount_pos = i;
					break;
				}
				ret += source.substr(0, amount_pos + 1);
			}
			else {
				ret += source.substr(0, source.size() - precision + 1);
				std::string amoutFloat = source.substr(source.size() - precision);
				size_t amount_pos = 0;
				for (size_t i = amoutFloat.size() - 1; i > 0; i--) {
					if (amoutFloat[i] == 0) {
						continue;
					}
					amount_pos = i;
					break;
				}
				ret += amoutFloat.substr(0, amount_pos);
			}
			return ret;
		}
		std::string FillZero(std::string input, bool append_zero = true) {
			std::string ret;
			for (size_t i = input.size(); i < 64; ++i) {
				ret += '0';
			}
			if (append_zero)
			{
				ret = input + ret;
			}
			else {
				ret = ret + input;
			}
			return ret;
		}
		std::string UnFillZero(std::string input, bool append_zero = true) {
			size_t i = 0;
			if (append_zero)
			{
				for (int iLoop = input.size() - 1; iLoop > 0; iLoop--)
				{
					if (input[iLoop] != '0')
					{
						break;
					}
					++i;
				}
				return input.substr(0, input.size() - i);
			}
			else {
				for (; i < input.size(); ++i) {
					if (input[i] != '0') {
						break;
					}
				}
				return input.substr(i);
			}
		}
		const std::string TurnToEthAmount(const std::string& source, const int& precision) {
			std::string ret;
			size_t pos = source.find('.');
			if (pos == source.npos) {

				ret = source;
				for (size_t i = 0; i < precision; ++i)
				{
					ret += '0';
				}
			}
			else {
				ret = source.substr(0, pos);
				if (ret == "0")
				{
					ret = "";
				}
				std::string sour_float = source.substr(pos + 1);
				if (sour_float.size() > precision || sour_float.size() < 1)
				{
					FC_ASSERT("ERC serise amount error");
				}
				ret += sour_float;

				for (size_t i = 0; i < 18 - sour_float.size(); ++i)
				{
					ret += '0';
				}
			}
			std::cout << "Test log handle amount is " << ret << std::endl;
			return ret;
		}
		std::string ConvertPre(int old_base, int new_base, std::string source_str) {
			std::string ret;
			int data[1010];
			int output[1010];
			memset(output, 0, sizeof(output));
			for (int i = 0; i < source_str.length(); i++) {
				if (isalpha(source_str[i]))
					if (isupper(source_str[i]))
					{
						data[i] = source_str[i] - 'A' + 10;
					}
					else {
						data[i] = source_str[i] - 'a' + 10;
					}
				else
					data[i] = source_str[i] - '0';
			}
			int sum = 1;
			int d = 0;
			int len = source_str.length();
			int k = 0;
			while (sum) {
				sum = 0;
				for (int i = 0; i < len; i++) {
					d = data[i] / new_base;
					sum += d;
					if (i == len - 1) {
						output[k++] = data[i] % new_base;
					}
					else {
						data[i + 1] += (data[i] % new_base) * old_base;
					}
					data[i] = d;
				}
			}
			if (k == 0) {
				output[k] = 0;
				k--;
			}
			if (k == -1) {
				ret = "0";
			}
			else {
				for (int i = 0; i < k; i++) {
					if (output[k - i - 1] > 9) {
						ret += (char)(output[k - i - 1] + 'a' - 10);
						//cout << (char)(output[k - i - 1] + 'a' - 10);
					}
					else {
						ret += output[k - i - 1] + '0';
					}
				}
			}
			return ret;
		}
		bool  from_hex(const char *pSrc, std::vector<char> &pDst, unsigned int nSrcLength, unsigned int &nDstLength)
		{
			if (pSrc == 0)
			{
				return false;
			}

			nDstLength = 0;

			if (pSrc[0] == 0) // nothing to convert  
				return 0;

			// 计算需要转换的字节数  
			for (int j = 0; pSrc[j]; j++)
			{
				if (isxdigit(pSrc[j]))
					nDstLength++;
			}

			// 判断待转换字节数是否为奇数，然后加一  
			if (nDstLength & 0x01) nDstLength++;
			nDstLength /= 2;

			if (nDstLength > nSrcLength)
				return false;

			nDstLength = 0;

			int phase = 0;
			char temp_char;

			for (int i = 0; pSrc[i]; i++)
			{
				if (!isxdigit(pSrc[i]))
					continue;

				unsigned char val = pSrc[i] - (isdigit(pSrc[i]) ? 0x30 : (isupper(pSrc[i]) ? 0x37 : 0x57));

				if (phase == 0)
				{
					temp_char = val << 4;
					phase++;
				}
				else
				{
					temp_char |= val;
					phase = 0;
					pDst.push_back(temp_char);
					nDstLength++;
				}
			}

			return true;
		}
		void crosschain_interface_eth::initialize_config(fc::variant_object &json_config)
		{
			_config = json_config;
			_rpc_method = "POST";
			_rpc_url = "http://";
			_rpc_url = _rpc_url + _config["ip"].as_string() + ":" + std::string(_config["port"].as_string()) + "/api";
		}
		bool crosschain_interface_eth::valid_config()
		{
			if (_config.contains("ip") && _config.contains("port"))
				return true;
			return false;
		}
		bool crosschain_interface_eth::unlock_wallet(std::string wallet_name, std::string wallet_passprase, uint32_t duration)
		{
			return false;
		}

		bool crosschain_interface_eth::open_wallet(std::string wallet_name)
		{
			return false;
		}

		void crosschain_interface_eth::close_wallet()
		{

		}

		std::vector<std::string> crosschain_interface_eth::wallet_list()
		{
			return std::vector<std::string>();
		}

		bool graphene::crosschain::crosschain_interface_eth::create_wallet(std::string wallet_name, std::string wallet_passprase)
		{
			if (wallet_name.find("ERC") != wallet_name.npos){
				std::ostringstream req_body;
				req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Addr.AddErc\" ,\
				\"params\" : {\"chainId\":\"" << chain_type << "\" ,\"addr\": \"" << wallet_passprase << "\"}}";
				std::cout << req_body.str() << std::endl;
				fc::http::connection_sync conn;
				conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
				auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
				return true;
			}
			
			return false;
		}

		std::string crosschain_interface_eth::create_normal_account(std::string account_name)
		{
			auto ptr = graphene::privatekey_management::crosschain_management::get_instance().get_crosschain_prk(chain_type);
			if (ptr == nullptr)
				return "";
			ptr->generate();
			if (account_name == "guard"){
				std::ostringstream req_body;
				req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Addr.importAddr\" ,\
				\"params\" : {\"chainId\":\""<<chain_type<<"\" ,\"addr\": \"" << ptr->get_address() << "\"}}";
				std::cout << req_body.str() << std::endl;
				fc::http::connection_sync conn;
				conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
				auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
				//std::cout << std::string(response.body.begin(), response.body.end()) << std::endl;
			}
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Addr.importAddr\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << ptr->get_public_key() << "\"}}";
			std::cout << req_body.str() << std::endl;
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			//std::cout << std::string(response.body.begin(), response.body.end()) << std::endl;
			*/
			return ptr->get_wif_key();
		}

		std::map<std::string, std::string> crosschain_interface_eth::create_multi_sig_account(std::string account_name, std::vector<std::string> addresses, uint32_t nrequired)
		{
			if (account_name == "get_contract_address"){
				FC_ASSERT(addresses.size() == 1);
				std::map<std::string, std::string> mapa;
				std::ostringstream req_body;
				req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.getContractAddress\" ,\
				\"params\" : {\"trxId\": \"" << addresses[0] << "\"}}";
				//std::cout << req_body.str() << std::endl;
				fc::http::connection_sync conn;
				conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
				auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

				if (response.status == fc::http::reply::OK)
				{
					auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();
					
					FC_ASSERT(resp.contains("result"));
					auto contract_address = resp["result"].as_string();
					mapa["contract_address"] = contract_address;
					
				}
				return mapa;
			}
			else if (account_name == "import_contract_addr") {
				for (const auto& item : addresses)
				{
					std::string addr = item + "erc";
					std::ostringstream req_body;
					req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Addr.importAddr\" ,\
				\"params\" : {\"chainId\":\"" << chain_type << "\" ,\"addr\": \"" << addr << "\"}}";
					std::cout << req_body.str() << std::endl;
					fc::http::connection_sync conn;
					conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
					auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
				}
				std::map<std::string, std::string> mapa;
				return mapa;
			}
			else {
				const std::string multi_contract_sol_code = "60806040523480156200001157600080fd5b5060405162001b1038038062001b10833981018060405281019080805182019291906020018051906020019092919050505081816000825182118062000058575060fa8351115b156200006357600080fd5b8251600181905550600090505b82518110156200016a5782818151811015156200008957fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1660026001830161010081101515620000bd57fe5b0181905550600061010260008584815181101515620000d857fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541415156200011457600080fd5b60018101610102600085848151811015156200012c57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555080600101905062000070565b81600081905550505050505061198a80620001866000396000f3006080604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632f6eaac614610126578063313ce5671461018c5780634123cb6b146101bd578063472d71d1146101e8578063746c9171146102a157806386435354146102cc57806388671ad414610385578063aaf5eb68146104d1578063bfe370d9146104fc578063d57498ea14610581578063fc8fd1c514610635575b6000341115610124577fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c3334604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060405180910390a15b005b61018a600480360381019080803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506106c0565b005b34801561019857600080fd5b506101a16109cb565b604051808260ff1660ff16815260200191505060405180910390f35b3480156101c957600080fd5b506101d26109d0565b6040518082815260200191505060405180910390f35b3480156101f457600080fd5b5061025f60048036038101908080356000191690602001909291908035600019169060200190929190803560001916906020019092919080357effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690602001909291905050506109d6565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b3480156102ad57600080fd5b506102b6610aea565b6040518082815260200191505060405180910390f35b3480156102d857600080fd5b5061034360048036038101908080356000191690602001909291908035600019169060200190929190803560001916906020019092919080357effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169060200190929190505050610af0565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561039157600080fd5b50610456600480360381019080803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610b08565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561049657808201518184015260208101905061047b565b50505050905090810190601f1680156104c35780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156104dd57600080fd5b506104e6610ce9565b6040518082815260200191505060405180910390f35b34801561050857600080fd5b50610563600480360381019080803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290505050610cf4565b60405180826000191660001916815260200191505060405180910390f35b34801561058d57600080fd5b506105ba600480360381019080803590602001908201803590602001919091929391929390505050610d02565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156105fa5780820151818401526020810190506105df565b50505050905090810190601f1680156106275780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561064157600080fd5b506106be600480360381019080803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610da3565b005b60008060008060008094508573ffffffffffffffffffffffffffffffffffffffff1693506000841415156106f357600194505b7f74aec394922f1e1a4f69076a402d938ff381675095bfa243b4ca0ddb157f335485604051808215151515815260200191505060405180910390a1600092505b898990508310156109bf5760009150841561092c5760405180807f7472616e7366657228616464726573732c75696e7432353629000000000000008152506019019050604051809103902090507f45d12fd932344b934d41dca22d26334bdecf4b1e061a38d30f6143e117d7d5f78160405180827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200191505060405180910390a18573ffffffffffffffffffffffffffffffffffffffff16817c010000000000000000000000000000000000000000000000000000000090048b8b86818110151561083b57fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff168a8a87818110151561086657fe5b905060200201356040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506000604051808303816000875af19250505091507f74aec394922f1e1a4f69076a402d938ff381675095bfa243b4ca0ddb157f335482604051808215151515815260200191505060405180910390a16109b2565b898984818110151561093a57fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc898986818110151561097e57fe5b905060200201359081150290604051600060405180830381858888f193505050501580156109b0573d6000803e3d6000fd5b505b8280600101935050610733565b50505050505050505050565b601281565b60015481565b600080827f010000000000000000000000000000000000000000000000000000000000000090049050601b60ff16837f0100000000000000000000000000000000000000000000000000000000000000900460ff161015610a5b57601b837f010000000000000000000000000000000000000000000000000000000000000090040190505b600186828787604051600081526020016040526040518085600019166000191681526020018460ff1660ff1681526020018360001916600019168152602001826000191660001916815260200194505050505060206040516020810390808403906000865af1158015610ad2573d6000803e3d6000fd5b50505060206040510351915081915050949350505050565b60005481565b6000610afe858585856109d6565b9050949350505050565b60606000610b1533610e74565b1515610b2057600080fd5b8a8a90508d8d9050141515610b3457600080fd5b610bd08f8f8080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050508e8e808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508d8d8080602002602001604051908101604052809392919081815260200183836020028082843782019150505050505086610eaa565b9050610c6b818a8a80806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050898980806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050888880806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050611082565b50610cd6818e8e808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508d8d8080602002602001604051908101604052809392919081815260200183836020028082843782019150505050505086611204565b50509d9c50505050505050505050505050565b601260ff16600a0a81565b600060208201519050919050565b606060008090505b83839050811015610d9c5761010360008585848181101515610d2857fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690558080600101915050610d0a565b5092915050565b600087878787878787604051808888808284378201915050868660200280828437820191505084846020028082843782019150508273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401975050505050505050604051809103902090507fbe245d30dd9d24d0e4f4104cfd2a353f496e1aac7a8d1ec4c2a00ea88df774788160405180826000191660001916815260200191505060405180910390a15050505050505050565b60008061010260008473ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054119050919050565b6000806000868686866040518085805190602001908083835b602083101515610ee85780518252602082019150602081019050602083039250610ec3565b6001836020036101000a038019825116818451168082178552505050505050905001848051906020019060200280838360005b83811015610f36578082015181840152602081019050610f1b565b50505050905001838051906020019060200280838360005b83811015610f69578082015181840152602081019050610f4e565b505050509050018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401945050505050604051809103902091508160405160200180807f19457468657265756d205369676e6564204d6573736167653a0a333200000000815250601c0182600019166000191681526020019150506040516020818303038152906040526040518082805190602001908083835b6020831015156110465780518252602082019150602081019050602083039250611021565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902090508092505050949350505050565b6000806000808551875114158061109b57508451875114155b806110a857506000548751105b156110b257600080fd5b600092505b86518310156111f5576111118888858151811015156110d257fe5b9060200190602002015188868151811015156110ea57fe5b90602001906020020151888781518110151561110257fe5b90602001906020020151610af0565b91506001151561010360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161515141561117257600080fd5b600161010360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055506111d482610e74565b90506000151581151514156111e857600080fd5b82806001019350506110b7565b60019350505050949350505050565b6000806000806000808961121781611849565b151561122257600080fd5b600095508773ffffffffffffffffffffffffffffffffffffffff16945060008514151561124e57600195505b600093505b89518410156118065760009250851561147b5760405180807f7472616e7366657228616464726573732c75696e7432353629000000000000008152506019019050604051809103902091508773ffffffffffffffffffffffffffffffffffffffff16827c010000000000000000000000000000000000000000000000000000000090048b868151811015156112e457fe5b906020019060200201518b878151811015156112fc57fe5b906020019060200201516040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506000604051808303816000875af192505050925082151561139157600080fd5b7f0169d72b4638e9bc0f81e32c7cf97acd164b6d70e57234bc29346a946ae6ce1b8b8b868151811015156113c157fe5b906020019060200201518b878151811015156113d957fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a16117f9565b6000898581518110151561148b57fe5b906020019060200201511115806114c65750601260ff16600a0a6402540be4000289858151811015156114ba57fe5b90602001906020020151115b156115b5577f02f9603e9005f6b7992543a30e8694c19e07aa1695feb1e26d1f34ae6c0f86a68b8b868151811015156114fb57fe5b906020019060200201518b8781518110151561151357fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a16117f8565b89848151811015156115c357fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff166108fc8a868151811015156115f457fe5b906020019060200201519081150290604051600060405180830381858888f193505050509250600015158315151415611711577f02f9603e9005f6b7992543a30e8694c19e07aa1695feb1e26d1f34ae6c0f86a68b8b8681518110151561165757fe5b906020019060200201518b8781518110151561166f57fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a16117f7565b7f0169d72b4638e9bc0f81e32c7cf97acd164b6d70e57234bc29346a946ae6ce1b8b8b8681518110151561174157fe5b906020019060200201518b8781518110151561175957fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a15b5b5b8380600101945050611253565b600161010560008d6000191660001916815260200190815260200160002060006101000a81548160ff021916908315150217905550505050505050949350505050565b60008060008061010260003373ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549250600083141561188e5760009350611956565b6101056000866000191660001916815260200190815260200160002060009054906101000a900460ff169150600015158215151415156118d15760009350611956565b600090505b600154811015611951576101036000600260018401610100811015156118f857fe5b015473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff021916905580806001019150506118d6565b600193505b5050509190505600a165627a7a723058204df08b9c1c38513f69789084e5cd018e11959eb18fd0966f4afae74fec6313c10029";

				//std::string multi_contract_sol_code = "60806040523480156200001157600080fd5b50604051620027ae380380620027ae833981018060405281019080805182019291906020018051906020019092919050505081816000825182118062000058575060fa8351115b15620000645762000121565b8251600181905550600090505b8251811015620001195782818151811015156200008a57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1660026001830161010081101515620000be57fe5b01819055506001810161010260008584815181101515620000db57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555080600101905062000071565b816000819055505b505050505061267880620001366000396000f300608060405260043610610099576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632f6eaac6146101105780634123cb6b14610176578063472d71d1146101a1578063746c91711461025a578063864353541461028557806388671ad41461033e578063bfe370d91461048a578063d57498ea1461050f578063fc8fd1c5146105c3575b600034111561010e577fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c3334604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060405180910390a15b005b610174600480360381019080803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061064e565b005b34801561018257600080fd5b5061018b610959565b6040518082815260200191505060405180910390f35b3480156101ad57600080fd5b5061021860048036038101908080356000191690602001909291908035600019169060200190929190803560001916906020019092919080357effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916906020019092919050505061095f565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561026657600080fd5b5061026f610a73565b6040518082815260200191505060405180910390f35b34801561029157600080fd5b506102fc60048036038101908080356000191690602001909291908035600019169060200190929190803560001916906020019092919080357effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169060200190929190505050610a79565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561034a57600080fd5b5061040f600480360381019080803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610a91565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561044f578082015181840152602081019050610434565b50505050905090810190601f16801561047c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561049657600080fd5b506104f1600480360381019080803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290505050611030565b60405180826000191660001916815260200191505060405180910390f35b34801561051b57600080fd5b5061054860048036038101908080359060200190820180359060200191909192939192939050505061103e565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561058857808201518184015260208101905061056d565b50505050905090810190601f1680156105b55780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156105cf57600080fd5b5061064c600480360381019080803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506110df565b005b60008060008060008094508573ffffffffffffffffffffffffffffffffffffffff16935060008414151561068157600194505b7f74aec394922f1e1a4f69076a402d938ff381675095bfa243b4ca0ddb157f335485604051808215151515815260200191505060405180910390a1600092505b8989905083101561094d576000915084156108ba5760405180807f7472616e7366657228616464726573732c75696e7432353629000000000000008152506019019050604051809103902090507f45d12fd932344b934d41dca22d26334bdecf4b1e061a38d30f6143e117d7d5f78160405180827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200191505060405180910390a18573ffffffffffffffffffffffffffffffffffffffff16817c010000000000000000000000000000000000000000000000000000000090048b8b8681811015156107c957fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff168a8a8781811015156107f457fe5b905060200201356040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506000604051808303816000875af19250505091507f74aec394922f1e1a4f69076a402d938ff381675095bfa243b4ca0ddb157f335482604051808215151515815260200191505060405180910390a1610940565b89898481811015156108c857fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc898986818110151561090c57fe5b905060200201359081150290604051600060405180830381858888f1935050505015801561093e573d6000803e3d6000fd5b505b82806001019350506106c1565b50505050505050505050565b60015481565b600080827f010000000000000000000000000000000000000000000000000000000000000090049050601b60ff16837f0100000000000000000000000000000000000000000000000000000000000000900460ff1610156109e457601b837f010000000000000000000000000000000000000000000000000000000000000090040190505b600186828787604051600081526020016040526040518085600019166000191681526020018460ff1660ff1681526020018360001916600019168152602001826000191660001916815260200194505050505060206040516020810390808403906000865af1158015610a5b573d6000803e3d6000fd5b50505060206040510351915081915050949350505050565b60005481565b6000610a878585858561095f565b9050949350505050565b606060007fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600c8152602001807f496e206f6e6c796f776e6572000000000000000000000000000000000000000081525060200191505060405180910390a1610b06336111b0565b1515610b1157600080fd5b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600d8152602001807f6f7574206f6e6c796f776e65720000000000000000000000000000000000000081525060200191505060405180910390a17fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbcc";
				//multi_contract_sol_code+=	"f71fd8e66e047f98b60405180806020018281038252600c8152602001807f456e74657220766572696679000000000000000000000000000000000000000081525060200191505060405180910390a18a8a90508d8d9050141515610cda577fc58bfad19a3daf29712c5f372910c42f216b7589931750a111a1374974cf39b4600160405180806020018381526020018281038252600c8152602001807f6c656e676874206572726f7200000000000000000000000000000000000000008152506020019250505060405180910390a17f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe608d8d90506040518082815260200191505060405180910390a17f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe608b8b90506040518082815260200191505060405180910390a161101e565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600e8152602001807f456e74657220766572696679203100000000000000000000000000000000000081525060200191505060405180910390a1610dde8f8f8080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050508e8e808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508d8d80806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050866112f2565b90507fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600e8152602001807f456e74657220766572696679203200000000000000000000000000000000000081525060200191505060405180910390a1610ee1818a8a808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508989808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508888808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050506114ca565b507fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600e8152602001807f456e74657220766572696679203300000000000000000000000000000000000081525060200191505060405180910390a1610fb4818e8e808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508d8d8080602002602001604051908101604052809392919081815260200183836020028082843782019150505050505086611aae565b507fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600a8152602001807f656e64207665726966790000000000000000000000000000000000000000000081525060200191505060405180910390a15b509d9c50505050505050505050505050565b600060208201519050919050565b606060008090505b838390508110156110d8576101036000858584818110151561106457fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690558080600101915050611046565b5092915050565b600087878787878787604051808888808284378201915050868660200280828437820191505084846020028082843782019150508273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401975050505050505050604051809103902090507fbe245d30dd9d24d0e4f4104cfd2a353f496e1aac7a8d1ec4c2a00ea88df774788160405180826000191660001916815260200191505060405180910390a15050505050505050565b6000807fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600a8152602001807f496e2069734f776e65720000000000000000000000000000000000000000000081525060200191505060405180910390a17febfb412ded3f9cdb15b75308503b279416e74d382f6ce86eedee0ef3130fa9e383604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a1600061010260008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541190507f74aec394922f1e1a4f69076a402d938ff381675095bfa243b4ca0ddb157f335481604051808215151515815260200191505060405180910390a180915050919050565b6000806000868686866040518085805190602001908083835b602083101515611330578051825260208201915060208101905060208303925061130b565b6001836020036101000a038019825116818451168082178552505050505050905001848051906020019060200280838360005b8381101561137e578082015181840152602081019050611363565b50505050905001838051906020019060200280838360005b838110156113b1578082015181840152602081019050611396565b505050509050018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401945050505050604051809103902091508160405160200180807f19457468657265756d205369676e6564204d6573736167653a0a333200000000815250601c0182600019166000191681526020019150506040516020818303038152906040526040518082805190602001908083835b60208310151561148e5780518252602082019150602081019050602083039250611469565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902090508092505050949350505050565b6000806000807fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260118152602001807f456e746572207665726966795f7369676e00000000000000000000000000000081525060200191505060405180910390a18551875114158061154b57508451875114155b8061155857506000548751105b1561167b577fc58bfad19a3daf29712c5f372910c42f216b7589931750a111a1374974cf39b4600260405180806020018381526020018281038252600c8152602001807f6c656e676874206572726f7200000000000000000000000000000000000000008152506020019250505060405180910390a17f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe6087516040518082815260200191505060405180910390a17f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe6086516040518082815260200191505060405180910390a17f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe6085516040518082815260200191505060405180910390a1611aa3565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260168152602001807f456e746572207665726966795f7369676e20656c73650000000000000000000081525060200191505060405180910390a1600092505b86518310156119ce5761174288888581518110151561170357fe5b90602001906020020151888681518110151561171b57fe5b90602001906020020151888781518110151561173357fe5b90602001906020020151610a79565b91506001151561010360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1615151415611877577febfb412ded3f9cdb15b75308503b279416e74d382f6ce86eedee0ef3130fa9e382604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a17fc58bfad19a3daf29712c5f372910c42f216b7589931750a111a1374974cf39b4600160405180806020018381526020018281038252600b8152602001807f7374617465206572726f720000000000000000000000000000000000000000008152506020019250505060405180910390a1611aa3565b600161010360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055506118d9826111b0565b90506000151581151514156119c1577febfb412ded3f9cdb15b75308503b279416e74d382f6ce86eedee0ef3130fa9e382604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a17fc58bfad19a3daf29712c5f372910c42f216b7589931750a111a1374974cf39b4600260405180806020018381526020018281038252600b8152602001807f7374617465206572726f720000000000000000000000000000000000000000008152506020019250505060405180910390a1611aa3565b82806001019350506116e8565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260148152602001807f6f7574207665726966795f7369676e20656c736500000000000000000000000081525060200191505060405180910390a17fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600f8152602001807f6f7574207665726966795f7369676e000000000000000000000000000000000081525060200191505060405180910390a1600193505b505050949350505050565b600080600080600080897fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260118152602001807f496e206f6e6c796d616e796f776e65727300000000000000000000000000000081525060200191505060405180910390a1611b29816122fd565b1515611b3457600080fd5b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260128152602001807f6f7574206f6e6c796d616e796f776e657273000000000000000000000000000081525060200191505060405180910390a17fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600d8152602001807f456e74657220657865637574650000000000000000000000000000000000000081525060200191505060405180910390a1600095508773ffffffffffffffffffffffffffffffffffffffff169450600085141515611c3057600195505b600093505b895184101561225157600092508515611f99577fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260098152602001807f456e74657220657263000000000000000000000000000000000000000000000081525060200191505060405180910390a160405180807f7472616e7366657228616464726573732c75696e7432353629000000000000008152506019019050604051809103902091508773ffffffffffffffffffffffffffffffffffffffff16827c010000000000000000000000000000000000000000000000000000000090048b86815181101515611d2e57fe5b906020019060200201518b87815181101515611d4657fe5b906020019060200201516040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506000604051808303816000875af1925050509250821515611eaf577fc58bfad19a3daf29712c5f372910c42f216b7589931750a111a1374974cf39b460006040518080602001838152602001828103825260118152602001807f6572637472616e73666572206572726f720000000000000000000000000000008152506020019250505060405180910390a17febfb412ded3f9cdb15b75308503b279416e74d382f6ce86eedee0ef3130fa9e388604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a16122ef565b7f0169d72b4638e9bc0f81e32c7cf97acd164b6d70e57234bc29346a946ae6ce1b8b8b86815181101515611edf57fe5b906020019060200201518b87815181101515611ef757fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a1612244565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260098152602001807f456e74657220657468000000000000000000000000000000000000000000000081525060200191505060405180910390a1898481518110151561200f57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff166108fc8a8681518110151561204057fe5b906020019060200201519081150290604051600060405180830381858888f19350505050925060001515831515141561215d577f02f9603e9005f6b7992543a30e8694c19e07aa1695feb1e26d1f34ae6c0f86a68b8b868151811015156120a357fe5b906020019060200201518b878151811015156120bb57fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a1612243565b7f0169d72b4638e9bc0f81e32c7cf97acd164b6d70e57234bc29346a946ae6ce1b8b8b8681518110151561218d57fe5b906020019060200201518b878151811015156121a557fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a15b5b8380600101945050611c35565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600b8152602001807f6f7574206578656375746500000000000000000000000000000000000000000081525060200191505060405180910390a1600161010560008d6000191660001916815260200190815260200160002060006101000a81548160ff0219169083151502179055505b505050505050949350505050565b6000806000807fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260128152602001807f496e20636f6e6669726d416e64436865636b000000000000000000000000000081525060200191505060405180910390a17febfb412ded3f9cdb15b75308503b279416e74d382f6ce86eedee0ef3130fa9e333604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a161010260003373ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205492507f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe60836040518082815260200191505060405180910390a160008314156124ac577fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260178152602001807f496e20636f6e6669726d416e64436865636b203120696600000000000000000081525060200191505060405180910390a160009350612644565b6101056000866000191660001916815260200190815260200160002060009054906101000a900460ff16915060001515821515141515612557577fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260178152602001807f496e20636f6e6669726d416e64436865636b203220696600000000000000000081525060200191505060405180910390a160009350612644565b600090505b6001548110156125d75761010360006002600184016101008110151561257e57fe5b015473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055808060010191505061255c565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260198152602001807f496e20636f6e6669726d416e64436865636b20656e642069660000000000000081525060200191505060405180910390a1600193505b5050509190505600a165627a7a72305820627591ee1cc322f9649ece55fd8c3e2d34b6c0281ed13a319740065251a527a00029";
				const std::string address_offset = "0000000000000000000000000000000000000000000000000000000000000040";
				FC_ASSERT(int(nrequired) > 0);
				std::string hex_required = FillZero(ConvertPre(10, 16, fc::to_string(nrequired)), false);
				std::string hex_realaddr_size = FillZero(ConvertPre(10, 16, fc::to_string(addresses.size())), false);
				std::string hex_address = "";
				auto ptr = graphene::privatekey_management::crosschain_management::get_instance().get_crosschain_prk(chain_type);
				std::string signer = "";
				for (const auto & addr : addresses)
				{
					std::string temp = ptr->get_address_by_pubkey(addr);
					FC_ASSERT(temp.find("0x") != temp.npos, "ETH address type error");
					if (signer == "") {
						signer = temp;
					}
					temp = temp.substr(2);
					hex_address += FillZero(temp, false);
				}
				std::string to_data = multi_contract_sol_code + address_offset + hex_required + hex_realaddr_size + hex_address;

				dev::eth::TransactionSkeleton ret;
				ret.from = dev::jsToAddress(signer.substr(2));
				ret.gasPrice = dev::jsToU256("21000000000");
				ret.gas = dev::jsToU256("4500000");
				ret.creation = true;
				std::vector<char> bin_input;
				unsigned int nDeplength = 0;
				bool b_converse = from_hex(to_data.data(), bin_input, to_data.size(), nDeplength);
				FC_ASSERT(b_converse);
				dev::bytes temp_data(to_data.begin(), to_data.end());
				//std::cout << "to data is " <<to_data << std::endl;
				ret.data = dev::bytes(bin_input.begin(), bin_input.end());
				ret.value = dev::jsToU256("0");
				ret.chainId = 1;
				//获取nonce
				auto sep = account_name.find('|');
				std::string real_nonce;
				if (sep == account_name.npos) {
					std::string temp_nonce;
					std::ostringstream req_body;
					req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.getEthTrxCount\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << signer << "\",\"\indexFormat\":\"pending\"}}";
					//std::cout << req_body.str() << std::endl;
					fc::http::connection_sync conn;
					conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
					auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

					if (response.status == fc::http::reply::OK)
					{
						auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

						FC_ASSERT(resp.contains("result"));
						temp_nonce = resp["result"].as_string();
					}
					else {
						FC_THROW("get nonce error");
					}
					if (temp_nonce[0] == '0' && temp_nonce[1] == 'x')
					{
						temp_nonce = temp_nonce.substr(2);
					}
					std::string nonce = ConvertPre(16, 10, temp_nonce);
					real_nonce = fc::to_string(fc::to_int64(nonce));/*
					if (account_name.find("cold") != account_name.npos)
					{

					}
					else if (account_name.find("hot") != account_name.npos)
					{
						real_nonce = fc::to_string(fc::to_int64(nonce));
					}*/
				}
				else {
					real_nonce = account_name.substr(sep);
				}
				ret.nonce = dev::jsToU256(real_nonce);
				dev::eth::TransactionBase trx_base(ret);
				std::map<std::string, std::string> mapa;
				//std::cout << "trx base size is "<<trx_base.rlp(dev::eth::WithoutSignature).size() << std::endl;
				auto without_sign_tx = trx_base.rlp(dev::eth::WithoutSignature);

				std::string without_sign_trx(without_sign_tx.begin(), without_sign_tx.end());//std::string(.begin(), trx_base.rlp(dev::eth::WithoutSignature).end());
				mapa[signer] = to_hex(without_sign_trx.data(), without_sign_trx.size());
				mapa["nonce"] = real_nonce;
				//FC_ASSERT(false);
				return mapa;
			}
			
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
			\"id\" : \"45\", \
			\"method\" : \"Zchain.Multisig.Create\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"amount\": " << nrequired << ",\"" << "addrs\":[";

			for (int i = 0; i < addresses.size(); ++i)
			{
			req_body << "\"" << addresses[i] << "\"";
			if (i < addresses.size() - 1)
			{
			req_body << ",";
			}

			}
			req_body << "]}}";
			fc::http::connection_sync conn;
			std::cout << req_body.str() << std::endl;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			std::cout << response.status << std::endl;
			if (response.status == fc::http::reply::OK)
			{
			std::cout << std::string(response.body.begin(), response.body.end()) << std::endl;
			auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
			auto ret = resp.get_object();
			if (ret.contains("result"))
			{

			auto result = ret["result"].get_object();
			FC_ASSERT(result.contains("address"));
			map["address"] = result["address"].as_string();
			FC_ASSERT(result.contains("redeemScript"));
			map["redeemScript"] = result["redeemScript"].as_string();
			return map;
			}
			}

			FC_THROW(account_name);
			*/
			
			//return std::string();
		}

		std::vector<graphene::crosschain::hd_trx> crosschain_interface_eth::deposit_transaction_query(std::string user_account, uint32_t from_block, uint32_t limit)
		{
			return std::vector<graphene::crosschain::hd_trx>();
		}

		fc::variant_object crosschain_interface_eth::transaction_query(std::string trx_id)
		{
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.queryTrans\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"trxid\": \"" << trx_id << "\"}}";
			std::cout << req_body.str() << std::endl;
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

				FC_ASSERT(resp.contains("result"));
				FC_ASSERT(resp["result"].get_object().contains("data"));
				return resp["result"].get_object()["data"].get_object();
			}
			else
				FC_THROW(trx_id);
		}
		
		fc::variant_object crosschain_interface_eth::transfer(const std::string &from_account, const std::string &to_account, uint64_t amount, const std::string &symbol, const std::string &memo, bool broadcast /*= true*/)
		{
			return fc::variant_object();
		}
		int split(const std::string& str, std::vector<std::string>& ret_, std::string sep)
		{
			if (str.empty())
			{
				return 0;
			}

			std::string tmp;
			std::string::size_type pos_begin = str.find_first_not_of(sep);
			std::string::size_type comma_pos = 0;

			while (pos_begin != std::string::npos)
			{
				comma_pos = str.find(sep, pos_begin);
				if (comma_pos != std::string::npos)
				{
					tmp = str.substr(pos_begin, comma_pos - pos_begin);
					pos_begin = comma_pos + sep.length();
				}
				else
				{
					tmp = str.substr(pos_begin);
					pos_begin = comma_pos;
				}

				if (!tmp.empty())
				{
					ret_.push_back(tmp);
					tmp.clear();
				}
			}
			return 0;
		}
		crosschain_trx crosschain_interface_eth::turn_trxs(const fc::variant_object & trx)
		{
			hd_trx hdtx;
			crosschain_trx hdtxs;
			if (trx.contains("eth_trx")){
				std::string contract_addr = trx["eth_trx"]["contract_addr"].as_string();
				std::string msg_address = trx["eth_trx"]["msg_address"].as_string();
				std::string msg_amount = trx["eth_trx"]["msg_amount"].as_string();
				std::string msg_prefix = trx["eth_trx"]["msg_prefix"].as_string();
				FC_ASSERT((msg_amount.size() % 64 == 0 && msg_address.size() % 64 == 0 && msg_amount.size() == msg_address.size()), "eth msg_address or msg_account size error");
				for (size_t i = 0; i < msg_address.size() / 64; ++i) {
					hdtx.from_account = contract_addr;
					hdtx.asset_symbol = chain_type;
					std::string address = msg_address.substr(i * 64, 64);
					std::string real_address = UnFillZero(address);
					std::string amount = msg_amount.substr(i * 64, 64);
					std::string real_amount = TurnFromEthAmount(ConvertPre(16, 10, UnFillZero(amount)), 18);
					hdtx.to_account = "0x" + real_address;
					hdtx.amount = real_amount;
					hdtxs.trxs[hdtx.to_account] = hdtx;
				}
				hdtxs.fee = 0.0;
			}
			else if (trx.contains("turn_without_eth_sign")) {
				std::string contract_addr = trx["turn_without_eth_sign"]["contract_addr"].as_string();
				std::string msg_address = trx["turn_without_eth_sign"]["msg_address"].as_string();
				std::string msg_amount = trx["turn_without_eth_sign"]["msg_amount"].as_string();
				std::string msg_prefix = trx["turn_without_eth_sign"]["msg_prefix"].as_string();
				FC_ASSERT((msg_amount.size() % 64 == 0 && msg_address.size() % 64 == 0 && msg_amount.size() == msg_address.size()), "eth msg_address or msg_account size error");
				for (size_t i = 0; i < msg_address.size() / 64; ++i) {
					hdtx.from_account = contract_addr;
					hdtx.asset_symbol = chain_type;
					std::string address = msg_address.substr(i * 64,  64);
					std::string real_address = UnFillZero(address,false);
					std::string amount = msg_amount.substr(i * 64,  64);
					std::string real_amount = TurnFromEthAmount(ConvertPre(16, 10, UnFillZero(amount,false)), 18);
					hdtx.to_account = "0x" + real_address;
					hdtx.amount = real_amount;
					hdtxs.trxs[hdtx.to_account] = hdtx;
				}
				hdtxs.fee = 0.0;
			}
			else {

			}
			//"{\"from_addr\":\"" << from_account << "\",\"symbol\":\"" << symbol << "\",\"prefix\":\"" << msg_prefix << "\",\"msg_address\":\"" << msg_address << "\",\"msg_amount\":\""<< msg_amount <<"\"}"
			
			return hdtxs;
			
			/*
			try {
			auto tx = trx["trx"].get_object();
			hdtx.asset_symbol = chain_type;
			hdtx.trx_id = tx["txid"].as_string();
			const std::string to_addr = tx["vout"].get_array()[0].get_object()["scriptPubKey"].get_object()["addresses"].get_array()[0].as_string();

			double total_vin = 0.0;
			double total_vout = 0.0;
			// need to get the fee
			for (auto vin : tx["vin"].get_array())
			{
			auto index = vin.get_object()["vout"].as_uint64();
			auto from_trx_id = vin.get_object()["txid"].as_string();
			auto from_trx = transaction_query(from_trx_id);
			const std::string from_addr = from_trx["vout"].get_array()[index].get_object()["scriptPubKey"].get_object()["addresses"].get_array()[0].as_string();
			hdtx.from_account = from_addr;
			total_vin += from_trx["vout"].get_array()[index].get_object()["value"].as_double();
			}
			for (auto vouts : tx["vout"].get_array())
			{
			auto addrs = vouts.get_object()["scriptPubKey"].get_object()["addresses"].get_array();
			for (auto addr : addrs)
			{

			hdtx.to_account = addr.as_string();
			auto amount = vouts.get_object()["value"].as_double();
			if (addr.as_string() == hdtx.from_account)
			{
			total_vout += amount;
			continue;
			}
			char temp[1024];
			std::sprintf(temp, "%.8f", amount);

			hdtx.amount = graphene::utilities::remove_zero_for_str_amount(temp);
			total_vout += amount;
			hdtxs.trxs[hdtx.to_account] = hdtx;

			}

			}
			hdtxs.fee = total_vin - total_vout;
			}
			FC_CAPTURE_AND_RETHROW((trx));
			return hdtxs;
			*/
			
		}
		
		fc::variant_object crosschain_interface_eth::create_multisig_transaction(const std::string &from_account, const std::map<std::string, std::string> dest_info, const std::string &symbol, const std::string &memo)
		{
			auto sep_pos = memo.find('|');

			std::string msg_prefix = memo.substr(0,sep_pos);
			std::string cointype = "";
			if (sep_pos != memo.npos)
			{
				cointype = memo.substr(sep_pos + 1);
			}
			
			cointype = FillZero(cointype, false);
			std::string msg_address = "";
			std::string msg_amount = "";
			std::string contract_addr = from_account;
			for (auto iter = dest_info.begin();iter != dest_info.end();++iter){
				std::string to = iter->first;
				FC_ASSERT(to.size() <= 64, "eth address length error");
				FC_ASSERT((to[0] == '0'&& to[1] == 'x'));
				msg_address += FillZero(std::string(to.begin() + 2, to.end()),false);
			}
			for (auto iter = dest_info.begin(); iter != dest_info.end(); ++iter){
				std::string amount = TurnToEthAmount(iter->second,18);
				FC_ASSERT(amount.size() <= 64, "eth amount length error");
				msg_amount += FillZero(ConvertPre(10,16,amount),false);
			}
			std::ostringstream response_body;
			//fc::mutable_variant_object mobj;
			//mobj.set("cointype",)
			response_body << "{\"cointype\":\""<<cointype<<"\",\"contract_addr\":\"" << contract_addr << "\",\"symbol\":\"" << symbol << "\",\"msg_prefix\":\"" << msg_prefix << "\",\"msg_address\":\"" << msg_address << "\",\"msg_amount\":\""<< msg_amount <<"\"}";
			//response_body << "{\"contract_addr\":\"" << contract_addr << "\",\"symbol\":\"" << symbol << "\",\"msg_prefix\":\"" << msg_prefix << "\",\"msg_address\":\"" << msg_address << "\",\"msg_amount\":\"" << msg_amount << "\"}";
			//std::cout << std::string(response_body.str().begin(), response_body.str().end()) << std::endl;
			//auto resp = fc::json::from_string(std::string(response_body.str().begin(), response_body.str().end()));
			std::cout << response_body.str() << std::endl;
			auto resp = fc::json::from_string(response_body.str());
			return resp.get_object();
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.createTrx\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"from_addr\": \"" << from_account << "\",\"dest_info\":{";// << to_account << "\",\"amount\":" << amount << "}}";
			for (auto iter = dest_info.begin(); iter != dest_info.end(); ++iter)
			{
				if (iter != dest_info.begin())
					req_body << ",";
				req_body << "\"" << iter->first << "\":" << iter->second;
			}
			req_body << "}}}";
			fc::http::connection_sync conn;
			std::cout << req_body.str() << std::endl;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
				auto str = std::string(response.body.begin(), response.body.end());
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
				std::cout << "message is :" << std::string(response.body.begin(), response.body.end()) << std::endl;
				auto ret = resp.get_object()["result"].get_object();
				FC_ASSERT(ret.contains("data"));
				return ret["data"].get_object();
			}
			else
				FC_THROW("TODO");
			return fc::variant_object();
			*/
		}


		fc::variant_object crosschain_interface_eth::create_multisig_transaction(std::string &from_account, std::string &to_account, const std::string& amount, std::string &symbol, std::string &memo, bool broadcast)
		{
			dev::eth::TransactionSkeleton ret;
			ret.from = dev::jsToAddress(from_account);
			ret.gasPrice = dev::jsToU256("21000000000");
			ret.gas = dev::jsToU256("4500000");
			ret.to = dev::jsToAddress(to_account);
			ret.value = dev::jsToU256(TurnToEthAmount(amount, 18));
			ret.chainId = 1;
			std::string temp_nonce;
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
            \"id\" : \"45\", \
			\"method\" : \"Zchain.Trans.getEthTrxCount\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << from_account << "\",\"\indexFormat\":\"pending\"}}";
			//std::cout << req_body.str() << std::endl;
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

				FC_ASSERT(resp.contains("result"));
				temp_nonce = resp["result"].as_string();
			}
			else {
				FC_THROW("get nonce error");
			}
			/*if (temp_nonce[0] == '0' && temp_nonce[1] == 'x')
			{
				temp_nonce = temp_nonce.substr(2);
			}*/
			ret.nonce = dev::jsToU256(temp_nonce);
			dev::eth::TransactionBase trx_base(ret);
			//std::cout << "trx base size is "<<trx_base.rlp(dev::eth::WithoutSignature).size() << std::endl;
			auto without_sign_tx_bin = trx_base.rlp(dev::eth::WithoutSignature);
			//auto without_sign_tx = to_hex(without_sign_tx_bin.data(), without_sign_tx_bin.size());
			std::string without_sign_tx_bin_str(without_sign_tx_bin.begin(), without_sign_tx_bin.end());//std::string(.begin(), trx_base.rlp(dev::eth::WithoutSignature).end());
			auto without_sign_tx = to_hex(without_sign_tx_bin_str.data(), without_sign_tx_bin_str.size());
			return fc::variant_object("without_sign", without_sign_tx);
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.createTrx\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"from_addr\": \"" << from_account << "\",\"to_addr\":\"" << to_account << "\",\"amount\":" << amount << "}}";
			std::cout << req_body.str() << std::endl;
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
				auto str = std::string(response.body.begin(), response.body.end());
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
				auto ret = resp.get_object()["result"].get_object();
				FC_ASSERT(ret.contains("data"));
				return ret["data"].get_object();
			}
			else
				FC_THROW("TODO");*/
			return fc::variant_object();
		}

		std::string crosschain_interface_eth::sign_multisig_transaction(fc::variant_object trx, graphene::privatekey_management::crosschain_privatekey_base*& sign_key, const std::string& redeemScript, bool broadcast)
		{
			try {
				std::string signs;
				if (trx.contains("without_sign_trx_sign")|| trx.contains("get_param_hash")) {
					signs = sign_key->mutisign_trx(redeemScript, trx);
					
				}
				else {
					//TODO add turn trx to hash
					fc::mutable_variant_object ad = trx;
					std::string signs = sign_key->mutisign_trx(redeemScript, trx);
					ad.set("signs", signs);
					signs = fc::json::to_string(ad);
				}
				return signs;
				
			}
			FC_CAPTURE_AND_RETHROW((trx)(redeemScript));

			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
			\"id\" : \"45\", \
			\"method\" : \"Zchain.Trans.Sign\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << sign_account << "\",\"trx_hex\":\"" << trx["hex"].as_string() << "\","<<"\"redeemScript"<<"\":"<<"\""<<redeemScript<<"\"}}";
			std::cout << req_body.str() << std::endl;
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
			auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();
			std::cout << std::string(response.body.begin(), response.body.end()) << std::endl;
			FC_ASSERT(resp.contains("result"));
			auto ret = resp["result"].get_object();
			FC_ASSERT(ret.contains("data"));
			return ret["data"].get_object()["hex"].as_string();
			}
			else
			FC_THROW("TODO");
			return std::string();
			*/
		}
		std::string HandleEthString(std::string uprefix) {
			std::string uprefix_size = FillZero(ConvertPre(10, 16, fc::to_string(uprefix.size())),false);
			std::string uprefix_array;
			for (int i = 0; i <= (uprefix.size() /64);i++)
			{
				std::string temp = uprefix.substr(i * 64, 64);
				uprefix_array += FillZero(to_hex(temp.data(), temp.size()));
			}
			return uprefix_size + uprefix_array;
		}
		fc::variant_object crosschain_interface_eth::merge_multisig_transaction(fc::variant_object &trx, std::vector<std::string> signatures)
		{
			std::string signs_r;
			std::string signs_s;
			std::string signs_v;
			FC_ASSERT(trx.contains("signer"));
			FC_ASSERT(trx.contains("source_trx"));
			for (auto sign: signatures)
			{
				signs_r += sign.substr(0, 64);
				signs_s += sign.substr(64, 64);
				signs_v += FillZero(sign.substr(128),true);
			}
			
			//Call contract ,from is senator, to is multi contract
			std::string from_account = trx["signer"].as_string();
			std::string to_account = trx["source_trx"]["contract_addr"].as_string();
			std::string eth_cointype = trx["source_trx"]["cointype"].as_string();
			auto method_data = dev::sha3("verify(string,address[],uint256[],bytes32[],bytes32[],bytes1[],address)").asBytes();
			method_data.resize(4);
			auto eth_uprefix = HandleEthString(trx["source_trx"]["msg_prefix"].as_string());
			auto ad = trx["source_trx"]["msg_address"].as_string();
			auto ad_size = FillZero(ConvertPre(10, 16, fc::to_string(ad.size() / 64)),false);
			auto eth_address = ad_size + ad;
			auto amount = trx["source_trx"]["msg_amount"].as_string();
			auto amount_size = FillZero(ConvertPre(10, 16,fc::to_string(amount.size() / 64)), false);
			auto eth_amount = amount_size + amount;
			auto eth_sign_r = FillZero(ConvertPre(10, 16, fc::to_string(signs_r.size() / 64)), false) + signs_r;
			auto eth_sign_s = FillZero(ConvertPre(10, 16, fc::to_string(signs_s.size() / 64)), false) + signs_s;
			auto eth_sign_v = FillZero(ConvertPre(10, 16, fc::to_string(signs_v.size() / 64)), false) + signs_v;
			auto ethdata_head = FillZero(ConvertPre(10, 16, fc::to_string(7 * 32)), false) +
				FillZero((ConvertPre(10, 16, fc::to_string((7 + eth_uprefix.size() / 64) * 32))), false) +
				FillZero((ConvertPre(10, 16, fc::to_string((7 + (eth_uprefix.size() + eth_address.size()) / 64) * 32))), false) +
				FillZero((ConvertPre(10, 16, fc::to_string((7 + (eth_uprefix.size() + eth_address.size() + eth_amount.size()) / 64) * 32))), false) +
				FillZero((ConvertPre(10, 16, fc::to_string((7 + (eth_uprefix.size() + eth_address.size() + eth_amount.size() + eth_sign_r.size()) / 64) * 32))), false) +
				FillZero((ConvertPre(10, 16, fc::to_string((7 + (eth_uprefix.size() + eth_address.size() + eth_amount.size() + eth_sign_r.size() + eth_sign_s.size()) / 64) * 32))), false);
			auto eth_param = ethdata_head + eth_cointype+eth_uprefix + eth_address + eth_amount + eth_sign_r + eth_sign_s + eth_sign_v;
			
			
			dev::eth::TransactionSkeleton ret;
			ret.from = dev::jsToAddress(from_account);
			ret.to = dev::jsToAddress(to_account);
			ret.gasPrice = dev::jsToU256("21000000000");
			ret.gas = dev::jsToU256("4500000");
			std::vector<char> bin_input;
			unsigned int nDeplength = 0;
			bool b_converse = from_hex(eth_param.data(), bin_input, eth_param.size(), nDeplength);
			FC_ASSERT(b_converse);
			method_data.insert(method_data.end(), bin_input.begin(), bin_input.end());
			//std::cout << "to data is " <<to_data << std::endl;
			//ret.data = dev::bytes(bin_input.begin(), bin_input.end());
			ret.data = method_data;
			ret.value = dev::jsToU256("0");
			ret.chainId = 1;

			std::string real_nonce;
			if (trx.contains("nonce") == false) {
				std::string temp_nonce;
				std::ostringstream req_body;
				req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.getEthTrxCount\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << from_account << "\",\"\indexFormat\":\"pending\"}}";
				//std::cout << req_body.str() << std::endl;
				fc::http::connection_sync conn;
				conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
				auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

				if (response.status == fc::http::reply::OK)
				{
					auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

					FC_ASSERT(resp.contains("result"));
					temp_nonce = resp["result"].as_string();
				}
				else {
					FC_THROW("get nonce error");
				}
				if (temp_nonce[0] == '0' && temp_nonce[1] == 'x')
				{
					temp_nonce = temp_nonce.substr(2);
				}
				std::string nonce = ConvertPre(16, 10, temp_nonce);
				real_nonce = fc::to_string(fc::to_int64(nonce));
			}
			else {
				real_nonce = trx["nonce"].as_string();
			}
			ret.nonce = dev::jsToU256(real_nonce);
			//远程 eth_getTransactionCount pending获取nonce
			dev::eth::TransactionBase trx_base(ret);
			auto without_sign_tx = trx_base.rlp(dev::eth::WithoutSignature);

			std::string without_sign_trx(without_sign_tx.begin(), without_sign_tx.end());//std::string(.begin(), trx_base.rlp(dev::eth::WithoutSignature).end());
			fc::mutable_variant_object ret_trx = trx;
			auto hex_without_sign_trx = to_hex(without_sign_trx.data(), without_sign_trx.size());
			ret_trx.set("without_sign", hex_without_sign_trx);
			ret_trx.set("nonce",real_nonce);
			return ret_trx;
			//return fc::variant_object();
			/*
			auto method_data = sha3("verify(string,string,address)").asBytes();
			method_data.resize(4);
			auto dest = trx["dest_info_arg"].as_string();
			auto from_add = toBigEndian(jsToU256(trx["from_addr"].as_string()));
			method_data.insert(method_data.end(), dest.begin(), dest.end());
			method_data.insert(method_data.end(), signs.begin(), signs.end());
			method_data.insert(method_data.end(), from_add.begin(), from_add.end());
			*/
			
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
			\"id\" : \"45\", \
			\"method\" : \"Zchain.Trans.CombineTrx\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"transactions\": [";
			for (auto itr = signatures.begin(); itr != signatures.end(); ++itr)
			{
			req_body << "\"" << *itr << "\"";
			if (itr != signatures.end() - 1)
			{
			req_body << ",";
			}
			}
			req_body << "]}}";
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
			auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();
			FC_ASSERT(resp.contains("result"));
			auto ret = resp["result"].get_object();
			FC_ASSERT(ret.contains("data"));
			return ret["data"].get_object();
			}
			else
			FC_THROW(std::string(response.body.begin(), response.body.end()));
			return fc::variant_object();
			*/
			
		}

		bool crosschain_interface_eth::validate_link_trx(const hd_trx &trx)
		{
			return false;
		}

		bool crosschain_interface_eth::validate_link_trx(const std::vector<hd_trx> &trx)
		{
			return false;
		}

		bool crosschain_interface_eth::validate_other_trx(const fc::variant_object &trx)
		{
			return true;
		}
		bool crosschain_interface_eth::validate_address(const std::string& addr)
		{

			graphene::privatekey_management::eth_privatekey btk;
			return btk.validate_address(addr);
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
			\"id\" : \"45\", \
			\"method\" : \"Zchain.Address.validate\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"addr\": " << "\"" << addr <<"\"}}";
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
			auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
			auto ret = resp.get_object();
			if (ret.contains("result"))
			{
			auto result = ret["result"].get_object();
			return result["valid"].as_bool();
			}
			else
			{
			return false;
			}

			}
			else
			FC_THROW(addr);
			*/
		}

		bool crosschain_interface_eth::validate_signature(const std::string &account, const std::string &content, const std::string &signature)
		{
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Crypt.VerifyMessage\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"addr\": " << "\"" << account << "\"," << "\"message\":" << "\""  \
				<< content << "\"," << "\"" << "signature" << "\":\"" << signature << "\"" << "}}";
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
				auto ret = resp.get_object();
				if (ret.contains("result"))
				{
					auto result = ret["result"].get_object();
					return result["data"].as_bool();
				}
				else
				{
					return false;
				}

			}
			else
				FC_THROW(signature);
		}

		bool crosschain_interface_eth::create_signature(graphene::privatekey_management::crosschain_privatekey_base*& sign_key, const std::string &content, std::string &signature)
		{
			signature = "";
			signature = "0x" + sign_key->sign_message(content);
			if (signature == "")
				return false;
			return true;
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
			\"id\" : \"45\", \
			\"method\" : \"Zchain.Crypt.Sign\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"addr\": " <<"\""<<account<<"\"," <<"\"message\":"<<"\""<<content<<"\"" <<"}}";
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
			auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
			auto result=resp.get_object();
			if (result.contains("result"))
			{
			signature = result["result"].get_object()["data"].as_string();
			return true;
			}
			return false;
			}
			else
			FC_THROW(signature);
			return true;
			*/
		}


		graphene::crosschain::hd_trx crosschain_interface_eth::turn_trx(const fc::variant_object & trx)
		{
			hd_trx hdtx;
			try {
				if (trx.contains("get_without_sign")){
					std::vector<char> temp;
					unsigned int nDeplength = 0;
					std::string eth_trx = trx["get_without_sign"].as_string();
					bool b_converse = from_hex(eth_trx.data(), temp, eth_trx.size(), nDeplength);
					FC_ASSERT(b_converse);
					dev::bytes trx_temp(temp.begin(), temp.end());
					dev::eth::TransactionBase trx_base(trx_temp, dev::eth::CheckTransaction::None);
					hdtx.from_account = trx_base.from().hex();
					auto without_sign_tx = trx_base.rlp(dev::eth::WithoutSignature);
					std::string input_trx(without_sign_tx.begin(), without_sign_tx.end());
					hdtx.to_account = to_hex(input_trx.data(),input_trx.size());
					hdtx.asset_symbol = chain_type;
					hdtx.amount = trx_base.value().str();
					//auto bin = trx_base.sha3();
					//std::vector<char> vectorBin(bin.begin(), bin.end());
					//hdtx.trx_id = to_hex(vectorBin.data(),vectorBin.size());
				}
				else if (trx.contains("trx")){
					//TODO handle eth & erc chain_type
					std::string source_trx = trx["trx"].as_string();
					dev::bytes temp(source_trx.begin(), source_trx.end());
					dev::eth::TransactionBase eth_trx(temp,dev::eth::CheckTransaction::None);
					hdtx.from_account = eth_trx.from().hex();
					std::string input_trx(eth_trx.rlp(dev::eth::WithoutSignature).begin(), eth_trx.rlp(dev::eth::WithoutSignature).end());
					hdtx.to_account = input_trx;
					hdtx.asset_symbol = chain_type;
					hdtx.amount = eth_trx.value().str();
				}
				else if(trx.contains("plugin_get_trx")){
					auto real_trx = trx["plugin_get_trx"];
					hdtx.trx_id = real_trx.get_object()["txid"].as_string();
					hdtx.from_account = real_trx.get_object()["from_account"].as_string();
					hdtx.asset_symbol = chain_type;
					hdtx.amount = real_trx.get_object()["amount"].as_string();
					hdtx.block_num = real_trx.get_object()["blockNum"].as_int64();
					auto input = real_trx.get_object()["input"].as_string();
					hdtx.to_account = real_trx.get_object()["to_account"].as_string();
					if (input != "0x0"){
						hdtx.to_account += '|'+real_trx.get_object()["input"].as_string();
					}
					if (real_trx.get_object().contains("index")){
						hdtx.to_account += '|' + real_trx.get_object()["index"].as_string();
					}
				}
				else if (trx.contains("get_with_sign")) {
					std::vector<char> temp;
					unsigned int nDeplength = 0;
					std::string eth_trx = trx["get_with_sign"].as_string();
					bool b_converse = from_hex(eth_trx.data(), temp, eth_trx.size(), nDeplength);
					FC_ASSERT(b_converse);
					dev::bytes trx_temp(temp.begin(), temp.end());
					dev::eth::TransactionBase trx_base(trx_temp, dev::eth::CheckTransaction::None);
					hdtx.from_account = trx_base.from().hex();
					hdtx.to_account = trx_base.to().hex();
					auto input_temp = trx_base.data();
					std::vector<char> vector_input(input_temp.begin(), input_temp.end());
					auto hex_temp = to_hex(vector_input.data(), vector_input.size());
					std::string input = "0x" + hex_temp;
					if (input != "0x0") {
						hdtx.to_account += '|' + input;
					}
					//auto without_sign_tx = trx_base.rlp(dev::eth::WithoutSignature);
					//std::string input_trx(without_sign_tx.begin(), without_sign_tx.end());
					//hdtx.to_account = to_hex(input_trx.data(), input_trx.size());
					hdtx.asset_symbol = chain_type;
					hdtx.amount = trx_base.value().str();
					auto bin = trx_base.sha3();
					std::vector<char> vectorBin(bin.begin(), bin.end());
					hdtx.trx_id = "0x"+to_hex(vectorBin.data(),vectorBin.size());
				}
				return hdtx;
			}
			FC_CAPTURE_AND_RETHROW((trx));
			return hdtx;
		}

		void crosschain_interface_eth::broadcast_transaction(const fc::variant_object &trx)
		{
			try {
				std::ostringstream req_body;
				req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.broadcastTrx\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"trx\": " << "\"" << trx["trx"].as_string() << "\"" << "}}";
				fc::http::connection_sync conn;
				conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
				auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
				if (response.status == fc::http::reply::OK)
				{
					auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
					auto result = resp.get_object();
					if (result.contains("result"))
					{
						auto data_obj = result["result"].get_object();
						if (data_obj.contains("data"))
						{
							auto hex = data_obj["data"].as_string();
						}
						else {
							std::cout << std::string(response.body.begin(), response.body.end()) << std::endl;
						}
					}
				}
			}FC_CAPTURE_AND_LOG((trx));
		}

		std::vector<fc::variant_object> crosschain_interface_eth::query_account_balance(const std::string &account)
		{
			return std::vector<fc::variant_object>();
		}

		std::vector<fc::variant_object> crosschain_interface_eth::transaction_history(std::string symbol, const std::string &user_account, uint32_t start_block, uint32_t limit, uint32_t& end_block_num)
		{
			std::vector<fc::variant_object> return_value;
			std::string local_symbol = "eth";
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Transaction.Deposit.History\" ,\
				\"params\" : {\"chainId\":\"" << local_symbol << "\",\"account\": \"\" ,\"limit\": 0 ,\"blockNum\": " << start_block << "}}";
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
				//std::cout << std::string(response.body.begin(), response.body.end());
				auto result = resp.get_object();
				if (result.contains("result"))
				{
					end_block_num = result["result"].get_object()["blockNum"].as_uint64();
					for (auto one_data : result["result"].get_object()["data"].get_array())
					{
						//std::cout << one_data.get_object()["txid"].as_string();
						return_value.push_back(one_data.get_object());
					}
				}
			}
			std::ostringstream req_body1;
			req_body1 << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Transaction.Withdraw.History\" ,\
				\"params\" : {\"chainId\":\"" << local_symbol << "\",\"account\": \"\" ,\"limit\": 0 ,\"blockNum\": " << start_block << "}}";
			fc::http::connection_sync conn1;
			conn1.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response1 = conn1.request(_rpc_method, _rpc_url, req_body1.str(), _rpc_headers);
			if (response1.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response1.body.begin(), response1.body.end()));
				//std::cout << std::string(response.body.begin(), response.body.end());
				auto result = resp.get_object();
				if (result.contains("result"))
				{
					end_block_num = std::max(uint32_t(result["result"].get_object()["blockNum"].as_uint64()), end_block_num);
					for (auto one_data : result["result"].get_object()["data"].get_array())
					{
						//std::cout << one_data.get_object()["txid"].as_string();
						return_value.push_back(one_data.get_object());
					}
				}
			}
			std::ostringstream req_body2;
			req_body2 << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Transaction.GuardCall.History\" ,\
				\"params\" : {\"chainId\":\"" << "eth" << "\",\"account\": \"\" ,\"limit\": 0 ,\"blockNum\": " << start_block << "}}";
			fc::http::connection_sync conn2;
			conn1.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response2 = conn1.request(_rpc_method, _rpc_url, req_body2.str(), _rpc_headers);
			if (response2.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response2.body.begin(), response2.body.end()));
				//std::cout << std::string(response.body.begin(), response.body.end());
				auto result = resp.get_object();
				if (result.contains("result"))
				{
					end_block_num = std::max(uint32_t(result["result"].get_object()["blockNum"].as_uint64()), end_block_num);
					for (auto one_data : result["result"].get_object()["data"].get_array())
					{
						//std::cout << one_data.get_object()["txid"].as_string();
						return_value.push_back(one_data.get_object());
					}
				}
			}

			return return_value;
		}

		std::string crosschain_interface_eth::export_private_key(std::string &account, std::string &encrypt_passprase)
		{
			std::ostringstream req_body;
			req_body << "{ \"id\": 1, \"method\": \"dumpprivkey\", \"params\": [\""
				<< account << "\"]}";
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).as<fc::mutable_variant_object>();
				return resp["result"].as_string();
			}
			else
				FC_THROW(account);
		}

		std::string crosschain_interface_eth::import_private_key(std::string &account, std::string &encrypt_passprase)
		{
			return std::string();
		}

		std::string crosschain_interface_eth::backup_wallet(std::string &wallet_name, std::string &encrypt_passprase)
		{
			return std::string();
		}

		std::string crosschain_interface_eth::recover_wallet(std::string &wallet_name, std::string &encrypt_passprase)
		{
			return std::string();
		}
	}
}
