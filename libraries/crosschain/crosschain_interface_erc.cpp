#include <stdio.h>
#include <graphene/crosschain/crosschain_interface_erc.hpp>
#include <fc/network/ip.hpp>
#include <fc/network/tcp_socket.hpp>
#include <fc/io/json.hpp>
#include <fc/variant.hpp>
#include <fc/variant_object.hpp>
#include <iostream>
#include <graphene/crosschain_privatekey_management/private_key.hpp>
#include <libethcore/TransactionBase.h>
#include <libethcore/Common.h>
#include <libethcore/CommonJS.h>
#include <libdevcrypto/DevCryptoCommon.h>
#include <libdevcore/CommonData.h>

/*

#include <libethcore/TransactionBase.h>
#include <libethcore/Common.h>
#include <libethcore/CommonJS.h>
#include <libdevcrypto/DevCryptoCommon.h>
#include <libdevcore/CommonData.h>
*/

namespace graphene {
	namespace crosschain {
		namespace erc {
			std::string to_hex(const char* d, uint32_t s)
			{
				std::string r;
				const char* to_hex = "0123456789abcdef";
				uint8_t* c = (uint8_t*)d;
				for (uint32_t i = 0; i < s; ++i)
					(r += to_hex[(c[i] >> 4)]) += to_hex[(c[i] & 0x0f)];
				return r;
			}
			int split(const std::string& str, std::vector<std::string>& ret_, std::string sep)
			{
				if (str.empty())
				{
					return 0;
				}

				std::string tmp;
				std::string::size_type pos_begin = str.find_first_not_of(sep);
				std::string::size_type comma_pos = 0;

				while (pos_begin != std::string::npos)
				{
					comma_pos = str.find(sep, pos_begin);
					if (comma_pos != std::string::npos)
					{
						tmp = str.substr(pos_begin, comma_pos - pos_begin);
						pos_begin = comma_pos + sep.length();
					}
					else
					{
						tmp = str.substr(pos_begin);
						pos_begin = comma_pos;
					}

					if (!tmp.empty())
					{
						ret_.push_back(tmp);
						tmp.clear();
					}
				}
				return 0;
			}
			std::string to_hex(const std::vector<char>& data)
			{
				if (data.size())
					return to_hex(data.data(), data.size());
				return "";
			}
			const std::string TurnFromEthAmount(const std::string& source, const int& precision) {
				std::string ret;
				if (source.size() <= precision) {
					ret += "0.";
					std::string temp_precision((precision - source.size()), '0');
					ret += temp_precision;
					size_t amount_pos = source.find_last_not_of('0');
					if (amount_pos != source.npos)
					{
						ret += source.substr(0, amount_pos + 1);
					}
					else {
						ret += source;
					}

				}
				else {
					ret += source.substr(0, source.size() - precision);
					std::string amountFloat = source.substr(source.size() - precision);
					size_t amount_pos = amountFloat.find_last_not_of('0');
					if (amount_pos != amountFloat.npos)
					{
						ret += '.';
						ret += amountFloat.substr(0, amount_pos + 1);
					}

				}
				return ret;
			}
			std::string FillZero(std::string input, bool append_zero = true) {
				std::string ret((64 - input.size()), '0');
				if (append_zero)
				{
					ret = input + ret;
				}
				else {
					ret = ret + input;
				}
				return ret;
			}
			std::string UnFillZero(std::string input, bool append_zero = true) {
				size_t i = 0;
				if (append_zero)
				{
					auto temp_pos = input.find_last_not_of('0');
					if (temp_pos != input.npos) {
						return input.substr(0, temp_pos + 1);
					}
					else {
						return input;
					}
				}
				else {
					auto temp_pos = input.find_first_not_of('0');
					return input.substr(temp_pos);
				}
			}
			const std::string TurnToEthAmount(const std::string& source, const int& precision) {
				std::string ret;
				size_t pos = source.find('.');
				if (pos == source.npos) {
					ret = source;
					std::string temp(precision, '0');
					ret += temp;
				}
				else {
					ret = source.substr(0, pos);
					if (ret == "0")
					{
						ret = "";
					}
					std::string sour_float = source.substr(pos + 1);
					if (sour_float.size() > precision || sour_float.size() < 1)
					{
						FC_ASSERT(false,"ERC serise amount error");
					}
					ret += sour_float;
					std::string temp((precision - sour_float.size()), '0');
					ret += temp;
				}
				auto temp_pos = ret.find_first_not_of('0');
				if (temp_pos != ret.npos) {
					ret = ret.substr(temp_pos);
				}
				//ret = ret.substr(temp_pos);
				std::cout << "Test log handle amount is " << ret << std::endl;
				return ret;
			}
			std::string ConvertPre(int old_base, int new_base, std::string source_str) {
				std::string ret;
				int data[1010];
				int output[1010];
				memset(output, 0, sizeof(output));
				for (int i = 0; i < source_str.length(); i++) {
					if (isalpha(source_str[i]))
						if (isupper(source_str[i]))
						{
							data[i] = source_str[i] - 'A' + 10;
						}
						else {
							data[i] = source_str[i] - 'a' + 10;
						}
					else
						data[i] = source_str[i] - '0';
				}
				int sum = 1;
				int d = 0;
				int len = source_str.length();
				int k = 0;
				while (sum) {
					sum = 0;
					for (int i = 0; i < len; i++) {
						d = data[i] / new_base;
						sum += d;
						if (i == len - 1) {
							output[k++] = data[i] % new_base;
						}
						else {
							data[i + 1] += (data[i] % new_base) * old_base;
						}
						data[i] = d;
					}
				}
				if (k == 0) {
					output[k] = 0;
					k--;
				}
				if (k == -1) {
					ret = "0";
				}
				else {
					for (int i = 0; i < k; i++) {
						if (output[k - i - 1] > 9) {
							ret += (char)(output[k - i - 1] + 'a' - 10);
							//cout << (char)(output[k - i - 1] + 'a' - 10);
						}
						else {
							ret += output[k - i - 1] + '0';
						}
					}
				}
				return ret;
			}
			bool  from_hex(const char *pSrc, std::vector<char> &pDst, unsigned int nSrcLength, unsigned int &nDstLength)
			{
				if (pSrc == 0)
				{
					return false;
				}

				nDstLength = 0;

				if (pSrc[0] == 0) // nothing to convert  
					return 0;

				// 计算需要转换的字节数  
				for (int j = 0; pSrc[j]; j++)
				{
					if (isxdigit(pSrc[j]))
						nDstLength++;
				}

				// 判断待转换字节数是否为奇数，然后加一  
				if (nDstLength & 0x01) nDstLength++;
				nDstLength /= 2;

				if (nDstLength > nSrcLength)
					return false;

				nDstLength = 0;

				int phase = 0;
				char temp_char;

				for (int i = 0; pSrc[i]; i++)
				{
					if (!isxdigit(pSrc[i]))
						continue;

					unsigned char val = pSrc[i] - (isdigit(pSrc[i]) ? 0x30 : (isupper(pSrc[i]) ? 0x37 : 0x57));

					if (phase == 0)
					{
						temp_char = val << 4;
						phase++;
					}
					else
					{
						temp_char |= val;
						phase = 0;
						pDst.push_back(temp_char);
						nDstLength++;
					}
				}

				return true;
			}
			std::string HandleEthString(std::string uprefix) {
				std::string uprefix_size = erc::FillZero(erc::ConvertPre(10, 16, fc::to_string(uprefix.size())), false);
				std::string uprefix_array;
				for (int i = 0; i <= (uprefix.size() / 64); i++)
				{
					std::string temp = uprefix.substr(i * 64, 64);
					uprefix_array += erc::FillZero(erc::to_hex(temp.data(), temp.size()));
				}
				return uprefix_size + uprefix_array;
			}
		}
		
		void crosschain_interface_erc::initialize_config(fc::variant_object &json_config)
		{
			_config = json_config;
			_rpc_method = "POST";
			_rpc_url = "http://";
			_rpc_url = _rpc_url + _config["ip"].as_string() + ":" + std::string(_config["port"].as_string()) + "/api";
		}
		bool crosschain_interface_erc::valid_config()
		{
			if (_config.contains("ip") && _config.contains("port"))
				return true;
			return false;
		}
		bool crosschain_interface_erc::unlock_wallet(std::string wallet_name, std::string wallet_passprase, uint32_t duration)
		{
			return false;
		}

		bool crosschain_interface_erc::open_wallet(std::string wallet_name)
		{
			return false;
		}

		void crosschain_interface_erc::close_wallet()
		{

		}

		std::vector<std::string> crosschain_interface_erc::wallet_list()
		{
			return std::vector<std::string>();
		}

		bool graphene::crosschain::crosschain_interface_erc::create_wallet(std::string wallet_name, std::string wallet_passprase)
		{
			/*
			if (wallet_name.find("ERC") != wallet_name.npos){
				auto pre_pos = wallet_passprase.find('|');
				FC_ASSERT(pre_pos != wallet_passprase.npos);
				std::string asset_addr = wallet_passprase.substr(0, pre_pos);
				std::string precison = wallet_passprase.substr(pre_pos+1);
				std::ostringstream req_body;
				req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Addr.AddErc\" ,\
				\"params\" : {\"chainId\":\"" << chain_type << "\" ,\"addr\": \"" << asset_addr << "\" ,\"precison\": \"" <<precison<<"\"}}";
				std::cout << req_body.str() << std::endl;
				fc::http::connection_sync conn;
				conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
				auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
				return true;
			}
			*/
			
			return false;
		}

		std::string crosschain_interface_erc::create_normal_account(std::string account_name, const fc::optional<fc::ecc::private_key> key/*=fc::optional<fc::ecc::private_key>()*/)
		{
			auto ptr = graphene::privatekey_management::crosschain_management::get_instance().get_crosschain_prk(chain_type);
			if (ptr == nullptr)
				return "";
			ptr->generate(key);
			if (account_name == "guard"){
				std::ostringstream req_body;
				req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Addr.importAddr\" ,\
				\"params\" : {\"chainId\":\""<<chain_type<<"\" ,\"addr\": \"" << ptr->get_address() << "\"}}";
				std::cout << req_body.str() << std::endl;
				fc::http::connection_sync conn;
				//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
				//auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
				//std::cout << std::string(response.body.begin(), response.body.end()) << std::endl;
			}
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Addr.importAddr\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << ptr->get_public_key() << "\"}}";
			std::cout << req_body.str() << std::endl;
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			//std::cout << std::string(response.body.begin(), response.body.end()) << std::endl;
			*/
			return ptr->get_wif_key();
		}

		std::map<std::string, std::string> crosschain_interface_erc::create_multi_sig_account(std::string account_name, std::vector<std::string> addresses, uint32_t nrequired)
		{
			if (account_name == "get_contract_address"){
				FC_ASSERT(addresses.size() == 1);
				std::map<std::string, std::string> mapa;
				std::ostringstream req_body;
				req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.getContractAddress\" ,\
				\"params\" : {\"trxId\": \"" << addresses[0] << "\"}}";
				//std::cout << req_body.str() << std::endl;
				fc::http::connection_sync conn;

				connect_midware(conn);
				//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
				auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

				if (response.status == fc::http::reply::OK)
				{
					auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();
					
					FC_ASSERT(resp.contains("result"));
					auto contract_address = resp["result"].as_string();
					mapa["contract_address"] = contract_address;
					
				}
				return mapa;
			}
			else if (account_name == "import_contract_addr") {
				for (const auto& item : addresses)
				{
					std::string addr = item + "erc";
					std::ostringstream req_body;
					req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Addr.importAddr\" ,\
				\"params\" : {\"chainId\":\"" << chain_type << "\" ,\"addr\": \"" << addr << "\"}}";
					std::cout << req_body.str() << std::endl;
					fc::http::connection_sync conn;

					connect_midware(conn);
					//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
					auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
				}
				std::map<std::string, std::string> mapa;
				return mapa;
			}
			else {
				const std::string multi_contract_sol_code = "608060405234801561001057600080fd5b506040516115363803806115368339810180604052810190808051820192919060200180519060200190929190505050818160008251821180610054575060fa8351115b1561005e57600080fd5b8251600181905550600090505b825181101561015e57828181518110151561008257fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff16600260018301610100811015156100b557fe5b01819055506000610102600085848151811015156100cf57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414151561010a57600080fd5b600181016101026000858481518110151561012157fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555080600101905061006b565b8160008190555050505050506113bd806101796000396000f30060806040526004361061008e576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063313ce567146101055780634123cb6b14610136578063472d71d114610161578063746c91711461021a578063864353541461024557806388671ad4146102fe578063aaf5eb681461044a578063bfe370d914610475575b6000341115610103577fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c3334604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060405180910390a15b005b34801561011157600080fd5b5061011a6104fa565b604051808260ff1660ff16815260200191505060405180910390f35b34801561014257600080fd5b5061014b6104ff565b6040518082815260200191505060405180910390f35b34801561016d57600080fd5b506101d860048036038101908080356000191690602001909291908035600019169060200190929190803560001916906020019092919080357effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169060200190929190505050610505565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561022657600080fd5b5061022f61064d565b6040518082815260200191505060405180910390f35b34801561025157600080fd5b506102bc60048036038101908080356000191690602001909291908035600019169060200190929190803560001916906020019092919080357effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169060200190929190505050610653565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561030a57600080fd5b506103cf600480360381019080803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061066b565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561040f5780820151818401526020810190506103f4565b50505050905090810190601f16801561043c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561045657600080fd5b5061045f61084c565b6040518082815260200191505060405180910390f35b34801561048157600080fd5b506104dc600480360381019080803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290505050610857565b60405180826000191660001916815260200191505060405180910390f35b601281565b60015481565b600080827f010000000000000000000000000000000000000000000000000000000000000090049050600060ff16837f0100000000000000000000000000000000000000000000000000000000000000900460ff16148061058f5750600160ff16837f0100000000000000000000000000000000000000000000000000000000000000900460ff16145b156105be57601b837f010000000000000000000000000000000000000000000000000000000000000090040190505b600186828787604051600081526020016040526040518085600019166000191681526020018460ff1660ff1681526020018360001916600019168152602001826000191660001916815260200194505050505060206040516020810390808403906000865af1158015610635573d6000803e3d6000fd5b50505060206040510351915081915050949350505050565b60005481565b600061066185858585610505565b9050949350505050565b6060600061067833610865565b151561068357600080fd5b8a8a90508d8d905014151561069757600080fd5b6107338f8f8080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050508e8e808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508d8d808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508661089b565b90506107ce818a8a80806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050898980806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050888880806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050610a73565b50610839818e8e808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508d8d8080602002602001604051908101604052809392919081815260200183836020028082843782019150505050505086610c37565b50509d9c50505050505050505050505050565b601260ff16600a0a81565b600060208201519050919050565b60008061010260008473ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054119050919050565b6000806000868686866040518085805190602001908083835b6020831015156108d957805182526020820191506020810190506020830392506108b4565b6001836020036101000a038019825116818451168082178552505050505050905001848051906020019060200280838360005b8381101561092757808201518184015260208101905061090c565b50505050905001838051906020019060200280838360005b8381101561095a57808201518184015260208101905061093f565b505050509050018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401945050505050604051809103902091508160405160200180807f19457468657265756d205369676e6564204d6573736167653a0a333200000000815250601c0182600019166000191681526020019150506040516020818303038152906040526040518082805190602001908083835b602083101515610a375780518252602082019150602081019050602083039250610a12565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902090508092505050949350505050565b600080600080600086518851141580610a8e57508551885114155b80610a9b57506000548851105b15610aa557600080fd5b61010560008a6000191660001916815260200190815260200160002060009054906101000a900460ff16935060001515841515141515610ae457600080fd5b600092505b8751831015610c2757610b43898985815181101515610b0457fe5b906020019060200201518986815181101515610b1c57fe5b906020019060200201518987815181101515610b3457fe5b90602001906020020151610653565b91506001151561010360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1615151415610ba457600080fd5b600161010360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550610c0682610865565b9050600015158115151415610c1a57600080fd5b8280600101935050610ae9565b6001945050505050949350505050565b60008060008060008089610c4a8161127c565b1515610c5557600080fd5b600095508773ffffffffffffffffffffffffffffffffffffffff169450600085141515610c8157600195505b600093505b895184101561123957600092508515610eae5760405180807f7472616e7366657228616464726573732c75696e7432353629000000000000008152506019019050604051809103902091508773ffffffffffffffffffffffffffffffffffffffff16827c010000000000000000000000000000000000000000000000000000000090048b86815181101515610d1757fe5b906020019060200201518b87815181101515610d2f57fe5b906020019060200201516040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506000604051808303816000875af1925050509250821515610dc457600080fd5b7f0169d72b4638e9bc0f81e32c7cf97acd164b6d70e57234bc29346a946ae6ce1b8b8b86815181101515610df457fe5b906020019060200201518b87815181101515610e0c57fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a161122c565b60008985815181101515610ebe57fe5b90602001906020020151111580610ef95750601260ff16600a0a6402540be400028985815181101515610eed57fe5b90602001906020020151115b15610fe8577f02f9603e9005f6b7992543a30e8694c19e07aa1695feb1e26d1f34ae6c0f86a68b8b86815181101515610f2e57fe5b906020019060200201518b87815181101515610f4657fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a161122b565b8984815181101515610ff657fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff166108fc8a8681518110151561102757fe5b906020019060200201519081150290604051600060405180830381858888f193505050509250600015158315151415611144577f02f9603e9005f6b7992543a30e8694c19e07aa1695feb1e26d1f34ae6c0f86a68b8b8681518110151561108a57fe5b906020019060200201518b878151811015156110a257fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a161122a565b7f0169d72b4638e9bc0f81e32c7cf97acd164b6d70e57234bc29346a946ae6ce1b8b8b8681518110151561117457fe5b906020019060200201518b8781518110151561118c57fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a15b5b5b8380600101945050610c86565b600161010560008d6000191660001916815260200190815260200160002060006101000a81548160ff021916908315150217905550505050505050949350505050565b60008060008061010260003373ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054925060008314156112c15760009350611389565b6101056000866000191660001916815260200190815260200160002060009054906101000a900460ff169150600015158215151415156113045760009350611389565b600090505b6001548110156113845761010360006002600184016101008110151561132b57fe5b015473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690558080600101915050611309565b600193505b5050509190505600a165627a7a723058203d25f84ab7457979afb11a847fcf6c567f2b76963c516e811e2694e731a087a50029";

				//std::string multi_contract_sol_code = "60806040523480156200001157600080fd5b50604051620027ae380380620027ae833981018060405281019080805182019291906020018051906020019092919050505081816000825182118062000058575060fa8351115b15620000645762000121565b8251600181905550600090505b8251811015620001195782818151811015156200008a57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1660026001830161010081101515620000be57fe5b01819055506001810161010260008584815181101515620000db57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555080600101905062000071565b816000819055505b505050505061267880620001366000396000f300608060405260043610610099576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632f6eaac6146101105780634123cb6b14610176578063472d71d1146101a1578063746c91711461025a578063864353541461028557806388671ad41461033e578063bfe370d91461048a578063d57498ea1461050f578063fc8fd1c5146105c3575b600034111561010e577fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c3334604051808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019250505060405180910390a15b005b610174600480360381019080803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061064e565b005b34801561018257600080fd5b5061018b610959565b6040518082815260200191505060405180910390f35b3480156101ad57600080fd5b5061021860048036038101908080356000191690602001909291908035600019169060200190929190803560001916906020019092919080357effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916906020019092919050505061095f565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561026657600080fd5b5061026f610a73565b6040518082815260200191505060405180910390f35b34801561029157600080fd5b506102fc60048036038101908080356000191690602001909291908035600019169060200190929190803560001916906020019092919080357effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169060200190929190505050610a79565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561034a57600080fd5b5061040f600480360381019080803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610a91565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561044f578082015181840152602081019050610434565b50505050905090810190601f16801561047c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561049657600080fd5b506104f1600480360381019080803590602001908201803590602001908080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050509192919290505050611030565b60405180826000191660001916815260200191505060405180910390f35b34801561051b57600080fd5b5061054860048036038101908080359060200190820180359060200191909192939192939050505061103e565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561058857808201518184015260208101905061056d565b50505050905090810190601f1680156105b55780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156105cf57600080fd5b5061064c600480360381019080803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506110df565b005b60008060008060008094508573ffffffffffffffffffffffffffffffffffffffff16935060008414151561068157600194505b7f74aec394922f1e1a4f69076a402d938ff381675095bfa243b4ca0ddb157f335485604051808215151515815260200191505060405180910390a1600092505b8989905083101561094d576000915084156108ba5760405180807f7472616e7366657228616464726573732c75696e7432353629000000000000008152506019019050604051809103902090507f45d12fd932344b934d41dca22d26334bdecf4b1e061a38d30f6143e117d7d5f78160405180827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815260200191505060405180910390a18573ffffffffffffffffffffffffffffffffffffffff16817c010000000000000000000000000000000000000000000000000000000090048b8b8681811015156107c957fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff168a8a8781811015156107f457fe5b905060200201356040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506000604051808303816000875af19250505091507f74aec394922f1e1a4f69076a402d938ff381675095bfa243b4ca0ddb157f335482604051808215151515815260200191505060405180910390a1610940565b89898481811015156108c857fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc898986818110151561090c57fe5b905060200201359081150290604051600060405180830381858888f1935050505015801561093e573d6000803e3d6000fd5b505b82806001019350506106c1565b50505050505050505050565b60015481565b600080827f010000000000000000000000000000000000000000000000000000000000000090049050601b60ff16837f0100000000000000000000000000000000000000000000000000000000000000900460ff1610156109e457601b837f010000000000000000000000000000000000000000000000000000000000000090040190505b600186828787604051600081526020016040526040518085600019166000191681526020018460ff1660ff1681526020018360001916600019168152602001826000191660001916815260200194505050505060206040516020810390808403906000865af1158015610a5b573d6000803e3d6000fd5b50505060206040510351915081915050949350505050565b60005481565b6000610a878585858561095f565b9050949350505050565b606060007fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600c8152602001807f496e206f6e6c796f776e6572000000000000000000000000000000000000000081525060200191505060405180910390a1610b06336111b0565b1515610b1157600080fd5b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600d8152602001807f6f7574206f6e6c796f776e65720000000000000000000000000000000000000081525060200191505060405180910390a17fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbcc";
				//multi_contract_sol_code+=	"f71fd8e66e047f98b60405180806020018281038252600c8152602001807f456e74657220766572696679000000000000000000000000000000000000000081525060200191505060405180910390a18a8a90508d8d9050141515610cda577fc58bfad19a3daf29712c5f372910c42f216b7589931750a111a1374974cf39b4600160405180806020018381526020018281038252600c8152602001807f6c656e676874206572726f7200000000000000000000000000000000000000008152506020019250505060405180910390a17f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe608d8d90506040518082815260200191505060405180910390a17f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe608b8b90506040518082815260200191505060405180910390a161101e565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600e8152602001807f456e74657220766572696679203100000000000000000000000000000000000081525060200191505060405180910390a1610dde8f8f8080601f0160208091040260200160405190810160405280939291908181526020018383808284378201915050505050508e8e808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508d8d80806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050866112f2565b90507fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600e8152602001807f456e74657220766572696679203200000000000000000000000000000000000081525060200191505060405180910390a1610ee1818a8a808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508989808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508888808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050506114ca565b507fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600e8152602001807f456e74657220766572696679203300000000000000000000000000000000000081525060200191505060405180910390a1610fb4818e8e808060200260200160405190810160405280939291908181526020018383602002808284378201915050505050508d8d8080602002602001604051908101604052809392919081815260200183836020028082843782019150505050505086611aae565b507fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600a8152602001807f656e64207665726966790000000000000000000000000000000000000000000081525060200191505060405180910390a15b509d9c50505050505050505050505050565b600060208201519050919050565b606060008090505b838390508110156110d8576101036000858584818110151561106457fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690558080600101915050611046565b5092915050565b600087878787878787604051808888808284378201915050868660200280828437820191505084846020028082843782019150508273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401975050505050505050604051809103902090507fbe245d30dd9d24d0e4f4104cfd2a353f496e1aac7a8d1ec4c2a00ea88df774788160405180826000191660001916815260200191505060405180910390a15050505050505050565b6000807fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600a8152602001807f496e2069734f776e65720000000000000000000000000000000000000000000081525060200191505060405180910390a17febfb412ded3f9cdb15b75308503b279416e74d382f6ce86eedee0ef3130fa9e383604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a1600061010260008573ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541190507f74aec394922f1e1a4f69076a402d938ff381675095bfa243b4ca0ddb157f335481604051808215151515815260200191505060405180910390a180915050919050565b6000806000868686866040518085805190602001908083835b602083101515611330578051825260208201915060208101905060208303925061130b565b6001836020036101000a038019825116818451168082178552505050505050905001848051906020019060200280838360005b8381101561137e578082015181840152602081019050611363565b50505050905001838051906020019060200280838360005b838110156113b1578082015181840152602081019050611396565b505050509050018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166c01000000000000000000000000028152601401945050505050604051809103902091508160405160200180807f19457468657265756d205369676e6564204d6573736167653a0a333200000000815250601c0182600019166000191681526020019150506040516020818303038152906040526040518082805190602001908083835b60208310151561148e5780518252602082019150602081019050602083039250611469565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902090508092505050949350505050565b6000806000807fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260118152602001807f456e746572207665726966795f7369676e00000000000000000000000000000081525060200191505060405180910390a18551875114158061154b57508451875114155b8061155857506000548751105b1561167b577fc58bfad19a3daf29712c5f372910c42f216b7589931750a111a1374974cf39b4600260405180806020018381526020018281038252600c8152602001807f6c656e676874206572726f7200000000000000000000000000000000000000008152506020019250505060405180910390a17f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe6087516040518082815260200191505060405180910390a17f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe6086516040518082815260200191505060405180910390a17f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe6085516040518082815260200191505060405180910390a1611aa3565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260168152602001807f456e746572207665726966795f7369676e20656c73650000000000000000000081525060200191505060405180910390a1600092505b86518310156119ce5761174288888581518110151561170357fe5b90602001906020020151888681518110151561171b57fe5b90602001906020020151888781518110151561173357fe5b90602001906020020151610a79565b91506001151561010360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1615151415611877577febfb412ded3f9cdb15b75308503b279416e74d382f6ce86eedee0ef3130fa9e382604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a17fc58bfad19a3daf29712c5f372910c42f216b7589931750a111a1374974cf39b4600160405180806020018381526020018281038252600b8152602001807f7374617465206572726f720000000000000000000000000000000000000000008152506020019250505060405180910390a1611aa3565b600161010360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055506118d9826111b0565b90506000151581151514156119c1577febfb412ded3f9cdb15b75308503b279416e74d382f6ce86eedee0ef3130fa9e382604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a17fc58bfad19a3daf29712c5f372910c42f216b7589931750a111a1374974cf39b4600260405180806020018381526020018281038252600b8152602001807f7374617465206572726f720000000000000000000000000000000000000000008152506020019250505060405180910390a1611aa3565b82806001019350506116e8565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260148152602001807f6f7574207665726966795f7369676e20656c736500000000000000000000000081525060200191505060405180910390a17fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600f8152602001807f6f7574207665726966795f7369676e000000000000000000000000000000000081525060200191505060405180910390a1600193505b505050949350505050565b600080600080600080897fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260118152602001807f496e206f6e6c796d616e796f776e65727300000000000000000000000000000081525060200191505060405180910390a1611b29816122fd565b1515611b3457600080fd5b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260128152602001807f6f7574206f6e6c796d616e796f776e657273000000000000000000000000000081525060200191505060405180910390a17fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600d8152602001807f456e74657220657865637574650000000000000000000000000000000000000081525060200191505060405180910390a1600095508773ffffffffffffffffffffffffffffffffffffffff169450600085141515611c3057600195505b600093505b895184101561225157600092508515611f99577fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260098152602001807f456e74657220657263000000000000000000000000000000000000000000000081525060200191505060405180910390a160405180807f7472616e7366657228616464726573732c75696e7432353629000000000000008152506019019050604051809103902091508773ffffffffffffffffffffffffffffffffffffffff16827c010000000000000000000000000000000000000000000000000000000090048b86815181101515611d2e57fe5b906020019060200201518b87815181101515611d4657fe5b906020019060200201516040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001828152602001925050506000604051808303816000875af1925050509250821515611eaf577fc58bfad19a3daf29712c5f372910c42f216b7589931750a111a1374974cf39b460006040518080602001838152602001828103825260118152602001807f6572637472616e73666572206572726f720000000000000000000000000000008152506020019250505060405180910390a17febfb412ded3f9cdb15b75308503b279416e74d382f6ce86eedee0ef3130fa9e388604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a16122ef565b7f0169d72b4638e9bc0f81e32c7cf97acd164b6d70e57234bc29346a946ae6ce1b8b8b86815181101515611edf57fe5b906020019060200201518b87815181101515611ef757fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a1612244565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260098152602001807f456e74657220657468000000000000000000000000000000000000000000000081525060200191505060405180910390a1898481518110151561200f57fe5b9060200190602002015173ffffffffffffffffffffffffffffffffffffffff166108fc8a8681518110151561204057fe5b906020019060200201519081150290604051600060405180830381858888f19350505050925060001515831515141561215d577f02f9603e9005f6b7992543a30e8694c19e07aa1695feb1e26d1f34ae6c0f86a68b8b868151811015156120a357fe5b906020019060200201518b878151811015156120bb57fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a1612243565b7f0169d72b4638e9bc0f81e32c7cf97acd164b6d70e57234bc29346a946ae6ce1b8b8b8681518110151561218d57fe5b906020019060200201518b878151811015156121a557fe5b906020019060200201518b886040518086600019166000191681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019550505050505060405180910390a15b5b8380600101945050611c35565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b60405180806020018281038252600b8152602001807f6f7574206578656375746500000000000000000000000000000000000000000081525060200191505060405180910390a1600161010560008d6000191660001916815260200190815260200160002060006101000a81548160ff0219169083151502179055505b505050505050949350505050565b6000806000807fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260128152602001807f496e20636f6e6669726d416e64436865636b000000000000000000000000000081525060200191505060405180910390a17febfb412ded3f9cdb15b75308503b279416e74d382f6ce86eedee0ef3130fa9e333604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390a161010260003373ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205492507f432cc6516825015332dc662a569788a7b0790ea2c6a53a601c743c54cbdafe60836040518082815260200191505060405180910390a160008314156124ac577fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260178152602001807f496e20636f6e6669726d416e64436865636b203120696600000000000000000081525060200191505060405180910390a160009350612644565b6101056000866000191660001916815260200190815260200160002060009054906101000a900460ff16915060001515821515141515612557577fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260178152602001807f496e20636f6e6669726d416e64436865636b203220696600000000000000000081525060200191505060405180910390a160009350612644565b600090505b6001548110156125d75761010360006002600184016101008110151561257e57fe5b015473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff0219169055808060010191505061255c565b7fecc6e546c902cb34b0ac849d3311a9758a2d7c29e8cdbccf71fd8e66e047f98b6040518080602001828103825260198152602001807f496e20636f6e6669726d416e64436865636b20656e642069660000000000000081525060200191505060405180910390a1600193505b5050509190505600a165627a7a72305820627591ee1cc322f9649ece55fd8c3e2d34b6c0281ed13a319740065251a527a00029";
				const std::string address_offset = "0000000000000000000000000000000000000000000000000000000000000040";
				FC_ASSERT(int(nrequired) > 0);
				std::string hex_required = erc::FillZero(erc::ConvertPre(10, 16, fc::to_string(nrequired)), false);
				std::string hex_realaddr_size = erc::FillZero(erc::ConvertPre(10, 16, fc::to_string(addresses.size())), false);
				std::string hex_address = "";
				auto ptr = graphene::privatekey_management::crosschain_management::get_instance().get_crosschain_prk(chain_type);
				std::string signer = "";
				std::vector<std::string> temp_addresses;
				for (const auto & addr : addresses)
				{
					std::string temp = ptr->get_address_by_pubkey(addr);
					FC_ASSERT(temp.find("0x") != temp.npos, "ERC address type error");
					temp_addresses.push_back(temp);
					temp = temp.substr(2);
					hex_address += erc::FillZero(temp, false);
				}
					try {
						std::ostringstream req_body;
						req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Addr.importAddrs\" ,\
				\"params\" : {\"chainId\":\"" << chain_type << "\" ,\"addrs\": [";
					for (auto itr = temp_addresses.begin(); itr != temp_addresses.end(); ++itr)
					{
						req_body << "\"" << *itr << "\"";
						if (itr != temp_addresses.end() - 1)
						{
							req_body << ",";
						}
					}
					req_body << "]}}";
						std::cout << req_body.str() << std::endl;
						fc::http::connection_sync conn;

						connect_midware(conn);
						//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
						auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
					}
					catch (...) {

				}
				std::string to_data = multi_contract_sol_code + address_offset + hex_required + hex_realaddr_size + hex_address;

				dev::eth::TransactionSkeleton ret;
				
				ret.gas = dev::jsToU256("3000000");
				ret.creation = true;
				std::vector<char> bin_input;
				unsigned int nDeplength = 0;
				bool b_converse = erc::from_hex(to_data.data(), bin_input, to_data.size(), nDeplength);
				FC_ASSERT(b_converse);
				dev::bytes temp_data(to_data.begin(), to_data.end());
				//std::cout << "to data is " <<to_data << std::endl;
				ret.data = dev::bytes(bin_input.begin(), bin_input.end());
				ret.value = dev::jsToU256("0");
				ret.chainId = 1;
				//获取nonce
				std::vector<std::string> sep_vec;
				std::string real_nonce;
				std::string gas_price = "5000000000";
				erc::split(account_name, sep_vec, "|");
				if (sep_vec.size() == 2) {
					signer = sep_vec[0];
					real_nonce = sep_vec[1];
				}
				else if (sep_vec.size() == 3) {
					gas_price = sep_vec[2];
					if (sep_vec[1] == "*") {
						signer = sep_vec[0];

					std::string temp_nonce;
					std::ostringstream req_body;
					req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.getEthTrxCount\" ,\
				\"params\" : {\"chainId\":\""<<chain_type<<"\" ,\"addr\": \"" << signer << "\",\"\indexFormat\":\"pending\"}}";
					//std::cout << req_body.str() << std::endl;
					fc::http::connection_sync conn;

					connect_midware(conn);
					//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
					auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

					if (response.status == fc::http::reply::OK)
					{
						auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

						FC_ASSERT(resp.contains("result"));
						temp_nonce = resp["result"].as_string();
					}
					else {
						FC_THROW("get nonce error");
					}
					if (temp_nonce[0] == '0' && temp_nonce[1] == 'x')
					{
						temp_nonce = temp_nonce.substr(2);
					}
					std::string nonce = erc::ConvertPre(16, 10, temp_nonce);
						real_nonce = fc::to_string(fc::to_int64(nonce));
					}
					else {
						signer = sep_vec[0];
						real_nonce = sep_vec[1];
					}
				}
				else {
					signer = account_name;

					std::string temp_nonce;
					std::ostringstream req_body;
					req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.getEthTrxCount\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << signer << "\",\"\indexFormat\":\"pending\"}}";
					//std::cout << req_body.str() << std::endl;
					fc::http::connection_sync conn;
					connect_midware(conn);
					//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
					auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

					if (response.status == fc::http::reply::OK)
					{
						auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

						FC_ASSERT(resp.contains("result"));
						temp_nonce = resp["result"].as_string();
					}
					else {
						FC_THROW("get nonce error");
					}
					if (temp_nonce[0] == '0' && temp_nonce[1] == 'x')
					{
						temp_nonce = temp_nonce.substr(2);
					}
					std::string nonce = erc::ConvertPre(16, 10, temp_nonce);
						real_nonce = fc::to_string(fc::to_int64(nonce));
				}
				ret.gasPrice = dev::jsToU256(gas_price);
				ret.nonce = dev::jsToU256(real_nonce);
				ret.from = dev::jsToAddress(signer.substr(2));
				dev::eth::TransactionBase trx_base(ret);
				std::map<std::string, std::string> mapa;
				//std::cout << "trx base size is "<<trx_base.rlp(dev::eth::WithoutSignature).size() << std::endl;
				auto without_sign_tx = trx_base.rlp(dev::eth::WithoutSignature);

				std::string without_sign_trx(without_sign_tx.begin(), without_sign_tx.end());//std::string(.begin(), trx_base.rlp(dev::eth::WithoutSignature).end());
				mapa[signer] =erc::to_hex(without_sign_trx.data(), without_sign_trx.size());
				mapa["nonce"] = real_nonce;
				mapa["gas_price"] = gas_price;
				//FC_ASSERT(false);
				return mapa;
			}
			
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
			\"id\" : \"45\", \
			\"method\" : \"Zchain.Multisig.Create\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"amount\": " << nrequired << ",\"" << "addrs\":[";

			for (int i = 0; i < addresses.size(); ++i)
			{
			req_body << "\"" << addresses[i] << "\"";
			if (i < addresses.size() - 1)
			{
			req_body << ",";
			}

			}
			req_body << "]}}";
			fc::http::connection_sync conn;
			std::cout << req_body.str() << std::endl;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			std::cout << response.status << std::endl;
			if (response.status == fc::http::reply::OK)
			{
			std::cout << std::string(response.body.begin(), response.body.end()) << std::endl;
			auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
			auto ret = resp.get_object();
			if (ret.contains("result"))
			{

			auto result = ret["result"].get_object();
			FC_ASSERT(result.contains("address"));
			map["address"] = result["address"].as_string();
			FC_ASSERT(result.contains("redeemScript"));
			map["redeemScript"] = result["redeemScript"].as_string();
			return map;
			}
			}

			FC_THROW(account_name);
			*/
			
			//return std::string();
		}

		std::vector<graphene::crosschain::hd_trx> crosschain_interface_erc::deposit_transaction_query(std::string user_account, uint32_t from_block, uint32_t limit)
		{
			return std::vector<graphene::crosschain::hd_trx>();
		}

		fc::variant_object crosschain_interface_erc::transaction_query(std::string trx_id)
		{
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.queryTrans\" ,\
				\"params\" : {\"chainId\":\""<<chain_type<<"\" ,\"trxid\": \"" << trx_id << "\"}}";
			std::cout << req_body.str() << std::endl;
			fc::http::connection_sync conn;
			connect_midware(conn);
			//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

				FC_ASSERT(resp.contains("result"));
				FC_ASSERT(resp["result"].get_object().contains("data"));
				return resp["result"].get_object()["data"].get_object();
			}
			else
				FC_THROW(trx_id);
		}
		
		fc::variant_object crosschain_interface_erc::transfer(const std::string &from_account, const std::string &to_account, uint64_t amount, const std::string &symbol, const std::string &memo, bool broadcast /*= true*/)
		{
			return fc::variant_object();
		}
		
		crosschain_trx crosschain_interface_erc::turn_trxs(const fc::variant_object & trx)
		{
			hd_trx hdtx;
			crosschain_trx hdtxs;
			if (trx.contains("eth_trx")){
				std::string contract_addr = trx["eth_trx"]["contract_addr"].as_string();
				std::string msg_address = trx["eth_trx"]["msg_address"].as_string();
				std::string msg_amount = trx["eth_trx"]["msg_amount"].as_string();
				std::string msg_prefix = trx["eth_trx"]["msg_prefix"].as_string();
				FC_ASSERT((msg_amount.size() % 64 == 0 && msg_address.size() % 64 == 0 && msg_amount.size() == msg_address.size()), "erc msg_address or msg_account size error");
				for (size_t i = 0; i < msg_address.size() / 64; ++i) {
					hdtx.from_account = contract_addr;
					hdtx.asset_symbol = chain_type;
					std::string address = msg_address.substr(i * 64, 64);
					std::string real_address = address.substr(24);
					std::string amount = msg_amount.substr(i * 64, 64);
					int64_t presicion = 18;
					if (trx.contains("precision"))
					{
						presicion = trx["precision"].as_int64();
					}
					std::string real_amount = erc::TurnFromEthAmount(erc::ConvertPre(16, 10, erc::UnFillZero(amount)), presicion);
					hdtx.to_account = "0x" + real_address;
					hdtx.amount = real_amount;
					hdtxs.trxs[hdtx.to_account] = hdtx;
				}
				hdtxs.fee = 0.0;
			}
			else if (trx.contains("turn_without_eth_sign")) {
				std::string contract_addr = trx["turn_without_eth_sign"]["contract_addr"].as_string();
				std::string msg_address = trx["turn_without_eth_sign"]["msg_address"].as_string();
				std::string msg_amount = trx["turn_without_eth_sign"]["msg_amount"].as_string();
				std::string msg_prefix = trx["turn_without_eth_sign"]["msg_prefix"].as_string();
				FC_ASSERT((msg_amount.size() % 64 == 0 && msg_address.size() % 64 == 0 && msg_amount.size() == msg_address.size()), "eth msg_address or msg_account size error");
				for (size_t i = 0; i < msg_address.size() / 64; ++i) {
					hdtx.from_account = contract_addr;
					hdtx.asset_symbol = chain_type;
					std::string address = msg_address.substr(i * 64,  64);
					std::string real_address = address.substr(24);
					std::string amount = msg_amount.substr(i * 64,  64);
					int64_t presicion = 18;
					if (trx.contains("precision"))
					{
						presicion = trx["precision"].as_int64();
					}
					std::string real_amount = erc::TurnFromEthAmount(erc::ConvertPre(16, 10, erc::UnFillZero(amount,false)), presicion);
					hdtx.to_account = "0x" + real_address;
					hdtx.amount = real_amount;
					hdtxs.trxs[hdtx.to_account] = hdtx;
				}
				hdtxs.fee = 0.0;
			}
			else {

			}
			//"{\"from_addr\":\"" << from_account << "\",\"symbol\":\"" << symbol << "\",\"prefix\":\"" << msg_prefix << "\",\"msg_address\":\"" << msg_address << "\",\"msg_amount\":\""<< msg_amount <<"\"}"
			
			return hdtxs;
			
			/*
			try {
			auto tx = trx["trx"].get_object();
			hdtx.asset_symbol = chain_type;
			hdtx.trx_id = tx["txid"].as_string();
			const std::string to_addr = tx["vout"].get_array()[0].get_object()["scriptPubKey"].get_object()["addresses"].get_array()[0].as_string();

			double total_vin = 0.0;
			double total_vout = 0.0;
			// need to get the fee
			for (auto vin : tx["vin"].get_array())
			{
			auto index = vin.get_object()["vout"].as_uint64();
			auto from_trx_id = vin.get_object()["txid"].as_string();
			auto from_trx = transaction_query(from_trx_id);
			const std::string from_addr = from_trx["vout"].get_array()[index].get_object()["scriptPubKey"].get_object()["addresses"].get_array()[0].as_string();
			hdtx.from_account = from_addr;
			total_vin += from_trx["vout"].get_array()[index].get_object()["value"].as_double();
			}
			for (auto vouts : tx["vout"].get_array())
			{
			auto addrs = vouts.get_object()["scriptPubKey"].get_object()["addresses"].get_array();
			for (auto addr : addrs)
			{

			hdtx.to_account = addr.as_string();
			auto amount = vouts.get_object()["value"].as_double();
			if (addr.as_string() == hdtx.from_account)
			{
			total_vout += amount;
			continue;
			}
			char temp[1024];
			std::sprintf(temp, "%.8f", amount);

			hdtx.amount = graphene::utilities::remove_zero_for_str_amount(temp);
			total_vout += amount;
			hdtxs.trxs[hdtx.to_account] = hdtx;

			}

			}
			hdtxs.fee = total_vin - total_vout;
			}
			FC_CAPTURE_AND_RercROW((trx));
			return hdtxs;
			*/
			
		}
		
		fc::variant_object crosschain_interface_erc::create_multisig_transaction(const std::string &from_account, const std::map<std::string, std::string> dest_info, const std::string &symbol, const std::string &memo)
		{
			std::vector<std::string> sep_vec;
			erc::split(memo, sep_vec, "|");
			FC_ASSERT(sep_vec.size() == 3);

			auto sep_pos = memo.find('|');

			std::string msg_prefix = sep_vec[0];
			std::string cointype = sep_vec[1];
			FC_ASSERT((cointype[0] == '0'&& cointype[1] == 'x'));
			cointype = cointype.substr(2);
			auto erc_real_precision = fc::to_int64(sep_vec[2]);
			
			cointype = erc::FillZero(cointype, false);
			std::string msg_address = "";
			std::string msg_amount = "";
			std::string contract_addr = from_account;
			for (auto iter = dest_info.begin();iter != dest_info.end();++iter){
				std::string to = iter->first;
				FC_ASSERT(to.size() <= 64, "erc address length error");
				FC_ASSERT((to[0] == '0'&& to[1] == 'x'));
				msg_address += erc::FillZero(std::string(to.begin() + 2, to.end()),false);
			}
			double all_amount = 0.0;
			for (auto iter = dest_info.begin(); iter != dest_info.end(); ++iter){
				std::string amount = erc::TurnToEthAmount(iter->second, erc_real_precision);
				all_amount += fc::to_double(iter->second);
				FC_ASSERT(amount.size() <= 64, "erc amount length error");
				msg_amount += erc::FillZero(erc::ConvertPre(10,16,amount),false);
			}
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Address.GetBalance\" ,\
				\"params\" : {\"chainId\":\""<< chain_type <<"\" ,\"addr\": \"" << contract_addr << "\"}}";
			fc::http::connection_sync conn;
			connect_midware(conn);
			//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

				FC_ASSERT(resp.contains("result"));
				FC_ASSERT(resp["result"].get_object().contains("balance"));
				FC_ASSERT(all_amount <= resp["result"].get_object()["balance"].as_double(), "need cold change");
			}
			else {
				FC_THROW("no balance");
			}
			std::ostringstream response_body;
			//fc::mutable_variant_object mobj;
			//mobj.set("cointype",)
			response_body << "{\"cointype\":\""<<cointype<<"\",\"contract_addr\":\"" << contract_addr << "\",\"symbol\":\"" << symbol << "\",\"msg_prefix\":\"" << msg_prefix << "\",\"msg_address\":\"" << msg_address << "\",\"msg_amount\":\""<< msg_amount <<"\"}";
			//response_body << "{\"contract_addr\":\"" << contract_addr << "\",\"symbol\":\"" << symbol << "\",\"msg_prefix\":\"" << msg_prefix << "\",\"msg_address\":\"" << msg_address << "\",\"msg_amount\":\"" << msg_amount << "\"}";
			//std::cout << std::string(response_body.str().begin(), response_body.str().end()) << std::endl;
			//auto resp = fc::json::from_string(std::string(response_body.str().begin(), response_body.str().end()));
			std::cout << response_body.str() << std::endl;
			auto resp = fc::json::from_string(response_body.str());
			return resp.get_object();
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.createTrx\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"from_addr\": \"" << from_account << "\",\"dest_info\":{";// << to_account << "\",\"amount\":" << amount << "}}";
			for (auto iter = dest_info.begin(); iter != dest_info.end(); ++iter)
			{
				if (iter != dest_info.begin())
					req_body << ",";
				req_body << "\"" << iter->first << "\":" << iter->second;
			}
			req_body << "}}}";
			fc::http::connection_sync conn;
			std::cout << req_body.str() << std::endl;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
				auto str = std::string(response.body.begin(), response.body.end());
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
				std::cout << "message is :" << std::string(response.body.begin(), response.body.end()) << std::endl;
				auto ret = resp.get_object()["result"].get_object();
				FC_ASSERT(ret.contains("data"));
				return ret["data"].get_object();
			}
			else
				FC_THROW("TODO");
			return fc::variant_object();
			*/
		}


		fc::variant_object crosschain_interface_erc::create_multisig_transaction(std::string &from_account, std::string &to_account, const std::string& amount, std::string &symbol, std::string &memo, bool broadcast)
		{
			
			auto pos = memo.find('|');
			FC_ASSERT(pos != memo.npos);
			std::string cointype = memo.substr(0,pos);
			std::string erc_real_precision = memo.substr(pos + 1);
			auto method_data = dev::sha3("transfer(address,uint256)").asBytes();
			method_data.resize(4);
			std::string transfer_amount = erc::TurnToEthAmount(amount,  fc::to_int64(erc_real_precision));
			FC_ASSERT(transfer_amount.size() <= 64, "erc amount length error");
			std::string msg_amount = erc::FillZero(erc::ConvertPre(10, 16, transfer_amount), false);
			dev::eth::TransactionSkeleton ret;
			std::string use_to_account;
			auto gas_price_pos = to_account.find('|');
			if (gas_price_pos != to_account.npos) {
				auto temp_to_account = to_account.substr(0, gas_price_pos);
				auto temp_gas_price = to_account.substr(gas_price_pos + 1);
				ret.gasPrice = dev::jsToU256(temp_gas_price);
				use_to_account = temp_to_account;
				if (temp_to_account[0] == '0' && temp_to_account[1] == 'x') {
					use_to_account = temp_to_account.substr(2);
				}
			}
			else {
				ret.gasPrice = dev::jsToU256("5000000000");
				use_to_account = to_account;
			if (to_account[0] == '0' && to_account[1] == 'x'){
				use_to_account = to_account.substr(2);
			}
			}
			std::string msg_to_account = erc::FillZero(use_to_account, false);
			auto eth_param = msg_to_account + msg_amount;
			ret.from = dev::jsToAddress(from_account);
			ret.gas = dev::jsToU256("90000");
			ret.to = dev::jsToAddress(cointype);
			//dev::jsToU256(erc::TurnToEthAmount(amount, fc::to_int64(erc_real_precision)));
			ret.value = dev::jsToU256("0");
			std::vector<char> bin_input;
			unsigned int nDeplength = 0;
			bool b_converse = erc::from_hex(eth_param.data(), bin_input, eth_param.size(), nDeplength);
			FC_ASSERT(b_converse);
			method_data.insert(method_data.end(), bin_input.begin(), bin_input.end());
			//std::cout << "to data is " <<to_data << std::endl;
			//ret.data = dev::bytes(bin_input.begin(), bin_input.end());
			ret.data = method_data;
			ret.chainId = 1;
			std::string temp_nonce;
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
            \"id\" : \"45\", \
			\"method\" : \"Zchain.Trans.getEthTrxCount\" ,\
			\"params\" : {\"chainId\":\""<<chain_type<<"\" ,\"addr\": \"" << from_account << "\",\"\indexFormat\":\"pending\"}}";
			//std::cout << req_body.str() << std::endl;
			fc::http::connection_sync conn;
			connect_midware(conn);
			//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

				FC_ASSERT(resp.contains("result"));
				temp_nonce = resp["result"].as_string();
			}
			else {
				FC_THROW("get nonce error");
			}
			/*if (temp_nonce[0] == '0' && temp_nonce[1] == 'x')
			{
				temp_nonce = temp_nonce.substr(2);
			}*/
			ret.nonce = dev::jsToU256(temp_nonce);
			dev::eth::TransactionBase trx_base(ret);
			//std::cout << "trx base size is "<<trx_base.rlp(dev::eth::WithoutSignature).size() << std::endl;
			auto without_sign_tx_bin = trx_base.rlp(dev::eth::WithoutSignature);
			//auto without_sign_tx = to_hex(without_sign_tx_bin.data(), without_sign_tx_bin.size());
			std::string without_sign_tx_bin_str(without_sign_tx_bin.begin(), without_sign_tx_bin.end());//std::string(.begin(), trx_base.rlp(dev::eth::WithoutSignature).end());
			auto without_sign_tx = erc::to_hex(without_sign_tx_bin_str.data(), without_sign_tx_bin_str.size());
			return fc::variant_object("without_sign", without_sign_tx);
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.createTrx\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"from_addr\": \"" << from_account << "\",\"to_addr\":\"" << to_account << "\",\"amount\":" << amount << "}}";
			std::cout << req_body.str() << std::endl;
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
				auto str = std::string(response.body.begin(), response.body.end());
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
				auto ret = resp.get_object()["result"].get_object();
				FC_ASSERT(ret.contains("data"));
				return ret["data"].get_object();
			}
			else
				FC_THROW("TODO");*/
			return fc::variant_object();
		}

		std::string crosschain_interface_erc::sign_multisig_transaction(fc::variant_object trx, graphene::privatekey_management::crosschain_privatekey_base*& sign_key, const std::string& redeemScript, bool broadcast)
		{
			try {
				std::string signs;
				if (trx.contains("without_sign_trx_sign")) {
					std::string sender = sign_key->get_address();
					std::ostringstream req_body;
					req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Address.GetBalance\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << sender << "\"}}";
					fc::http::connection_sync conn;

					connect_midware(conn);
					//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
					auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

					if (response.status == fc::http::reply::OK)
					{
						auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

						FC_ASSERT(resp.contains("result"));
						FC_ASSERT(resp["result"].get_object().contains("balance"));
						FC_ASSERT(0.025 <= resp["result"].get_object()["balance"].as_double(), "sender doesnt have enough money to send this transaction");
					}
					else {
						FC_THROW("no balance");
					}
					signs = sign_key->mutisign_trx(redeemScript, trx);
				}
				else if (trx.contains("change_signer_sign")){
					auto eth_trx = trx["change_signer_sign"].as_string();

					std::vector<char> temp;
					unsigned int nDeplength = 0;
					bool b_converse = erc::from_hex(eth_trx.data(), temp, eth_trx.size(), nDeplength);
					FC_ASSERT(b_converse);
					dev::bytes bin_trx(temp.begin(), temp.end());
					dev::eth::TransactionBase trx_base(bin_trx, dev::eth::CheckTransaction::None);

					std::string sender = sign_key->get_address();
					std::ostringstream req_body;
					req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Address.GetBalance\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << sender << "\"}}";
					fc::http::connection_sync conn;
					connect_midware(conn);
					//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
					auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

					if (response.status == fc::http::reply::OK)
					{
						auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

						FC_ASSERT(resp.contains("result"));
						FC_ASSERT(resp["result"].get_object().contains("balance"));
						FC_ASSERT(0.025 <= resp["result"].get_object()["balance"].as_double(), "sender doesnt have enough money to send this transaction");
					}
					else {
						FC_THROW("no balance");
					}
					std::string temp_nonce;
					std::ostringstream req_body_x;
					req_body_x << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.getEthTrxCount\" ,\
				\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << sender << "\",\"\indexFormat\":\"pending\"}}";
					//std::cout << req_body.str() << std::endl;
					fc::http::connection_sync conn_x;

					connect_midware(conn_x);
					//conn_x.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
					auto response_x = conn_x.request(_rpc_method, _rpc_url, req_body_x.str(), _rpc_headers);

					if (response_x.status == fc::http::reply::OK)
					{
						auto resp = fc::json::from_string(std::string(response_x.body.begin(), response_x.body.end())).get_object();

						FC_ASSERT(resp.contains("result"));
						temp_nonce = resp["result"].as_string();
					}
					else {
						FC_THROW("get nonce error");
					}
					if (temp_nonce[0] == '0' && temp_nonce[1] == 'x')
					{
						temp_nonce = temp_nonce.substr(2);
					}
					std::string nonce = erc::ConvertPre(16, 10, temp_nonce);
					auto real_nonce = fc::to_string(fc::to_int64(nonce));
					dev::eth::TransactionSkeleton ret;
					ret.from = dev::jsToAddress(sender);
					ret.to = dev::jsToAddress(trx_base.to().hex());
					ret.gasPrice = trx_base.gasPrice();
					ret.gas = trx_base.gas();
					ret.data = trx_base.data();
					ret.value = trx_base.value();
					ret.chainId = 1;
					ret.nonce = dev::jsToU256(real_nonce);
					dev::eth::TransactionBase new_trx_base(ret);
					auto without_sign_tx = new_trx_base.rlp(dev::eth::WithoutSignature);

					std::string without_sign_trx(without_sign_tx.begin(), without_sign_tx.end());//std::string(.begin(), trx_base.rlp(dev::eth::WithoutSignature).end());
					fc::mutable_variant_object new_ret_trx;
					auto hex_without_sign_trx = erc::to_hex(without_sign_trx.data(), without_sign_trx.size());
					new_ret_trx.set("without_sign_trx_sign", hex_without_sign_trx);
					signs = sign_key->mutisign_trx(redeemScript, new_ret_trx);
				}
				else if (trx.contains("get_param_hash"))
				{
					signs = sign_key->mutisign_trx(redeemScript, trx);
				}
				else {
					//TODO add turn trx to hash
					fc::mutable_variant_object ad = trx;
					std::string signs = sign_key->mutisign_trx(redeemScript, trx);
					ad.set("signs", signs);
					signs = fc::json::to_string(ad);
				}
				return signs;
				
			}
			FC_CAPTURE_AND_RETHROW((trx)(redeemScript));

			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
			\"id\" : \"45\", \
			\"method\" : \"Zchain.Trans.Sign\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"addr\": \"" << sign_account << "\",\"trx_hex\":\"" << trx["hex"].as_string() << "\","<<"\"redeemScript"<<"\":"<<"\""<<redeemScript<<"\"}}";
			std::cout << req_body.str() << std::endl;
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
			auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();
			std::cout << std::string(response.body.begin(), response.body.end()) << std::endl;
			FC_ASSERT(resp.contains("result"));
			auto ret = resp["result"].get_object();
			FC_ASSERT(ret.contains("data"));
			return ret["data"].get_object()["hex"].as_string();
			}
			else
			FC_THROW("TODO");
			return std::string();
			*/
		}
		
		fc::variant_object crosschain_interface_erc::merge_multisig_transaction(fc::variant_object &trx, std::vector<std::string> signatures)
		{
			std::string signs_r;
			std::string signs_s;
			std::string signs_v;
			FC_ASSERT(trx.contains("signer"));
			FC_ASSERT(trx.contains("source_trx"));
			for (auto sign: signatures)
			{
				signs_r += sign.substr(0, 64);
				signs_s += sign.substr(64, 64);
				signs_v += erc::FillZero(sign.substr(128),true);
			}
			std::string gas_price = "5000000000";
			if (trx.contains("gas_price"))
			{
				gas_price = trx["gas_price"].as_string();
			}
			//Call contract ,from is senator, to is multi contract
			std::string from_account = trx["signer"].as_string();
			std::string to_account = trx["source_trx"]["contract_addr"].as_string();
			std::string eth_cointype = trx["source_trx"]["cointype"].as_string();
			auto method_data = dev::sha3("verify(string,address[],uint256[],bytes32[],bytes32[],bytes1[],address)").asBytes();
			method_data.resize(4);
			auto eth_uprefix = erc::HandleEthString(trx["source_trx"]["msg_prefix"].as_string());
			auto ad = trx["source_trx"]["msg_address"].as_string();
			auto ad_size = erc::FillZero(erc::ConvertPre(10, 16, fc::to_string(ad.size() / 64)),false);
			auto eth_address = ad_size + ad;
			auto amount = trx["source_trx"]["msg_amount"].as_string();
			auto amount_size = erc::FillZero(erc::ConvertPre(10, 16,fc::to_string(amount.size() / 64)), false);
			auto eth_amount = amount_size + amount;
			auto eth_sign_r = erc::FillZero(erc::ConvertPre(10, 16, fc::to_string(signs_r.size() / 64)), false) + signs_r;
			auto eth_sign_s = erc::FillZero(erc::ConvertPre(10, 16, fc::to_string(signs_s.size() / 64)), false) + signs_s;
			auto eth_sign_v = erc::FillZero(erc::ConvertPre(10, 16, fc::to_string(signs_v.size() / 64)), false) + signs_v;
			auto ethdata_head = erc::FillZero(erc::ConvertPre(10, 16, fc::to_string(7 * 32)), false) +
				erc::FillZero((erc::ConvertPre(10, 16, fc::to_string((7 + eth_uprefix.size() / 64) * 32))), false) +
				erc::FillZero((erc::ConvertPre(10, 16, fc::to_string((7 + (eth_uprefix.size() + eth_address.size()) / 64) * 32))), false) +
				erc::FillZero((erc::ConvertPre(10, 16, fc::to_string((7 + (eth_uprefix.size() + eth_address.size() + eth_amount.size()) / 64) * 32))), false) +
				erc::FillZero((erc::ConvertPre(10, 16, fc::to_string((7 + (eth_uprefix.size() + eth_address.size() + eth_amount.size() + eth_sign_r.size()) / 64) * 32))), false) +
				erc::FillZero((erc::ConvertPre(10, 16, fc::to_string((7 + (eth_uprefix.size() + eth_address.size() + eth_amount.size() + eth_sign_r.size() + eth_sign_s.size()) / 64) * 32))), false);
			auto eth_param = ethdata_head + eth_cointype+eth_uprefix + eth_address + eth_amount + eth_sign_r + eth_sign_s + eth_sign_v;
			
			
			dev::eth::TransactionSkeleton ret;
			ret.from = dev::jsToAddress(from_account);
			ret.to = dev::jsToAddress(to_account);
			ret.gasPrice = dev::jsToU256(gas_price);
			ret.gas = dev::jsToU256("3000000");
			std::vector<char> bin_input;
			unsigned int nDeplength = 0;
			bool b_converse = erc::from_hex(eth_param.data(), bin_input, eth_param.size(), nDeplength);
			FC_ASSERT(b_converse);
			method_data.insert(method_data.end(), bin_input.begin(), bin_input.end());
			//std::cout << "to data is " <<to_data << std::endl;
			//ret.data = dev::bytes(bin_input.begin(), bin_input.end());
			ret.data = method_data;
			ret.value = dev::jsToU256("0");
			ret.chainId = 1;

			std::string real_nonce;
			if (trx.contains("nonce") == false) {
				std::string temp_nonce;
				std::ostringstream req_body;
				req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.getEthTrxCount\" ,\
				\"params\" : {\"chainId\":\""<<chain_type<<"\" ,\"addr\": \"" << from_account << "\",\"\indexFormat\":\"pending\"}}";
				//std::cout << req_body.str() << std::endl;
				fc::http::connection_sync conn;
				connect_midware(conn);
				//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
				auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

				if (response.status == fc::http::reply::OK)
				{
					auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();

					FC_ASSERT(resp.contains("result"));
					temp_nonce = resp["result"].as_string();
				}
				else {
					FC_THROW("get nonce error");
				}
				if (temp_nonce[0] == '0' && temp_nonce[1] == 'x')
				{
					temp_nonce = temp_nonce.substr(2);
				}
				std::string nonce = erc::ConvertPre(16, 10, temp_nonce);
				real_nonce = fc::to_string(fc::to_int64(nonce));
			}
			else {
				real_nonce = trx["nonce"].as_string();
			}
			ret.nonce = dev::jsToU256(real_nonce);
			//远程 eth_getTransactionCount pending获取nonce
			dev::eth::TransactionBase trx_base(ret);
			auto without_sign_tx = trx_base.rlp(dev::eth::WithoutSignature);

			std::string without_sign_trx(without_sign_tx.begin(), without_sign_tx.end());//std::string(.begin(), trx_base.rlp(dev::eth::WithoutSignature).end());
			fc::mutable_variant_object ret_trx = trx;
			auto hex_without_sign_trx = erc::to_hex(without_sign_trx.data(), without_sign_trx.size());
			ret_trx.set("without_sign", hex_without_sign_trx);
			ret_trx.set("nonce",real_nonce);
			return ret_trx;
			//return fc::variant_object();
			/*
			auto method_data = sha3("verify(string,string,address)").asBytes();
			method_data.resize(4);
			auto dest = trx["dest_info_arg"].as_string();
			auto from_add = toBigEndian(jsToU256(trx["from_addr"].as_string()));
			method_data.insert(method_data.end(), dest.begin(), dest.end());
			method_data.insert(method_data.end(), signs.begin(), signs.end());
			method_data.insert(method_data.end(), from_add.begin(), from_add.end());
			*/
			
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
			\"id\" : \"45\", \
			\"method\" : \"Zchain.Trans.CombineTrx\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"transactions\": [";
			for (auto itr = signatures.begin(); itr != signatures.end(); ++itr)
			{
			req_body << "\"" << *itr << "\"";
			if (itr != signatures.end() - 1)
			{
			req_body << ",";
			}
			}
			req_body << "]}}";
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
			auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).get_object();
			FC_ASSERT(resp.contains("result"));
			auto ret = resp["result"].get_object();
			FC_ASSERT(ret.contains("data"));
			return ret["data"].get_object();
			}
			else
			FC_THROW(std::string(response.body.begin(), response.body.end()));
			return fc::variant_object();
			*/
			
		}

		bool crosschain_interface_erc::validate_link_trx(const hd_trx &trx)
		{
			std::vector<std::string> sep_vec;
			erc::split(trx.to_account, sep_vec, "|");
			std::string trx_to_account, trx_input;
			std::string trx_index = "";
			FC_ASSERT(sep_vec.size() == 3);
			trx_to_account = sep_vec[0];
			trx_input = sep_vec[1];
			trx_index = sep_vec[2];
			
			std::vector<std::string> sep_symbol_vec;
			erc::split(trx.asset_symbol, sep_symbol_vec, "|");
			FC_ASSERT(sep_symbol_vec.size() == 3);
			auto erc_real_precision = fc::to_int64(sep_symbol_vec[2]);
			auto erc_address = sep_symbol_vec[1];
			std::string real_trx_id = trx.trx_id;
			if (trx.trx_id.find('|') != trx.trx_id.npos)
			{
				auto temp_pos = trx.trx_id.find('|');
				real_trx_id = trx.trx_id.substr(0, temp_pos);
			}
			auto tx = transaction_query(real_trx_id);
			FC_ASSERT(tx.contains("respit_trx"));
			FC_ASSERT(tx.contains("source_trx"));
			auto source_trx = tx["source_trx"].get_object();
			auto respit_trx = tx["respit_trx"].get_object();
			auto receipt_logs = respit_trx["logs"].get_array();
			bool ret = false;
			for (auto receipt_log : receipt_logs) {
				FC_ASSERT(receipt_log.get_object().contains("topics"));
				auto topics = receipt_log.get_object()["topics"].get_array();
				auto source_index = fc::to_uint64(erc::ConvertPre(16, 10, receipt_log["logIndex"].as_string().substr(2)));
				auto trx_index_num = fc::to_uint64(erc::ConvertPre(16, 10, trx_index));
				if (topics.size() == 1 &&(trx_index_num + 1 == source_index)){
					std::string success_topic = "0x0169d72b4638e9bc0f81e32c7cf97acd164b6d70e57234bc29346a946ae6ce1b";
					FC_ASSERT(topics[0].as_string() == success_topic);
					FC_ASSERT(receipt_log.get_object().contains("data"));
					std::string data = receipt_log.get_object()["data"].as_string();
					std::string logindex = receipt_log.get_object()["logIndex"].as_string();
					
					std::vector<std::string> datas;
					for (int i = 0; i < (data.size() - 2) / 64; ++i) {
						std::string temp_data = data.substr(2 + (i * 64), 64);
						datas.push_back(temp_data);
					}
					FC_ASSERT(datas.size() == 5);
					FC_ASSERT(datas[3] == erc_address);
					auto source_to_account = "0x" + datas[1].substr(24);
					auto temp_amount = erc::ConvertPre(16, 10, erc::UnFillZero(datas[2], false));
					auto source_amount =  erc::TurnFromEthAmount(temp_amount, erc_real_precision);
					auto source_from_account = source_trx["to"].as_string();
					FC_ASSERT(source_to_account == trx_to_account);
					FC_ASSERT(source_from_account == trx.from_account);
					FC_ASSERT(source_amount == trx.amount);
					ret = true;
					break;
				}
				else if (topics.size() > 2 && trx_index_num == source_index) {
					if (topics[0].as_string() != "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"){
						continue;
					}
					auto source_from_account = "0x" + topics[1].as_string().substr(26);
					auto source_to_account = "0x" + topics[2].as_string().substr(26);
					std::string data = receipt_log.get_object()["data"].as_string().substr(2);
					auto temp_amount = erc::ConvertPre(16, 10, erc::UnFillZero(data.substr(2), false));
					auto source_amount = erc::TurnFromEthAmount(temp_amount, erc_real_precision);
					//auto source_amount = erc::TurnFromEthAmount(data, erc_real_precision);
					FC_ASSERT(source_to_account == trx_to_account);
					FC_ASSERT(source_from_account == trx.from_account);
					FC_ASSERT(source_amount == trx.amount);
					ret = true;
					break;
				}
			}
			return ret;
		}

		bool crosschain_interface_erc::validate_link_trx(const std::vector<hd_trx> &trx)
		{
			return false;
		}

		bool crosschain_interface_erc::validate_other_trx(const fc::variant_object &trx)
		{
			return true;
		}
		bool crosschain_interface_erc::validate_transaction( const std::string& addr,const std::string& redeemscript,const std::string& sig)
		{
			try {
				return true;
			}FC_CAPTURE_AND_RETHROW((sig)(addr)(redeemscript));
		}

		bool crosschain_interface_erc::validate_address(const std::string& addr)
		{

			graphene::privatekey_management::eth_privatekey btk;
			return btk.validate_address(addr);
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
			\"id\" : \"45\", \
			\"method\" : \"Zchain.Address.validate\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"addr\": " << "\"" << addr <<"\"}}";
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
			auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
			auto ret = resp.get_object();
			if (ret.contains("result"))
			{
			auto result = ret["result"].get_object();
			return result["valid"].as_bool();
			}
			else
			{
			return false;
			}

			}
			else
			FC_THROW(addr);
			*/
		}

		bool crosschain_interface_erc::validate_signature(const std::string &account, const std::string &content, const std::string &signature)
		{
			graphene::privatekey_management::eth_privatekey etk;
			return etk.verify_message(account,content,signature);

			/*std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Crypt.VerifyMessage\" ,\
				\"params\" : {\"chainId\":\""<<chain_type<<"\" ,\"addr\": " << "\"" << account << "\"," << "\"message\":" << "\""  \
				<< content << "\"," << "\"" << "signature" << "\":\"" << signature << "\"" << "}}";
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
				auto ret = resp.get_object();
				if (ret.contains("result"))
				{
					auto result = ret["result"].get_object();
					return result["data"].as_bool();
				}
				else
				{
					return false;
				}

			}
			else
				FC_THROW(signature);*/
		}

		bool crosschain_interface_erc::create_signature(graphene::privatekey_management::crosschain_privatekey_base*& sign_key, const std::string &content, std::string &signature)
		{
			signature = "";
			signature = "0x" + sign_key->sign_message(content);
			if (signature == "")
				return false;
			return true;
			/*
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
			\"id\" : \"45\", \
			\"method\" : \"Zchain.Crypt.Sign\" ,\
			\"params\" : {\"chainId\":\"eth\" ,\"addr\": " <<"\""<<account<<"\"," <<"\"message\":"<<"\""<<content<<"\"" <<"}}";
			fc::http::connection_sync conn;
			conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
			auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
			auto result=resp.get_object();
			if (result.contains("result"))
			{
			signature = result["result"].get_object()["data"].as_string();
			return true;
			}
			return false;
			}
			else
			FC_THROW(signature);
			return true;
			*/
		}


		graphene::crosschain::hd_trx crosschain_interface_erc::turn_trx(const fc::variant_object & trx)
		{
			hd_trx hdtx;
			try {
				if (trx.contains("get_without_sign")){
					std::vector<char> temp;
					unsigned int nDeplength = 0;
					std::string eth_trx = trx["get_without_sign"].as_string();
					bool b_converse = erc::from_hex(eth_trx.data(), temp, eth_trx.size(), nDeplength);
					FC_ASSERT(b_converse);
					dev::bytes trx_temp(temp.begin(), temp.end());
					dev::eth::TransactionBase trx_base(trx_temp, dev::eth::CheckTransaction::None);
					hdtx.from_account = trx_base.from().hex();
					auto without_sign_tx = trx_base.rlp(dev::eth::WithoutSignature);
					std::string input_trx(without_sign_tx.begin(), without_sign_tx.end());
					hdtx.to_account = erc::to_hex(input_trx.data(),input_trx.size());
					hdtx.asset_symbol = chain_type;
					hdtx.amount = trx_base.value().str();
					//auto bin = trx_base.sha3();
					//std::vector<char> vectorBin(bin.begin(), bin.end());
					//hdtx.trx_id = to_hex(vectorBin.data(),vectorBin.size());
				}
				else if (trx.contains("trx")){
					//TODO handle eth & erc chain_type
					std::string source_trx = trx["trx"].as_string();
					dev::bytes temp(source_trx.begin(), source_trx.end());
					dev::eth::TransactionBase eth_trx(temp,dev::eth::CheckTransaction::None);
					hdtx.from_account = eth_trx.from().hex();
					std::string input_trx(eth_trx.rlp(dev::eth::WithoutSignature).begin(), eth_trx.rlp(dev::eth::WithoutSignature).end());
					hdtx.to_account = input_trx;
					hdtx.asset_symbol = chain_type;
					hdtx.amount = eth_trx.value().str();
				}
				else if(trx.contains("plugin_get_trx")){
					auto real_trx = trx["plugin_get_trx"];
					hdtx.trx_id = real_trx.get_object()["txid"].as_string();
					if (real_trx.get_object()["input"].as_string().size() > 10)
					{
						auto method_data = dev::sha3("verify(string,address[],uint256[],bytes32[],bytes32[],bytes1[],address)").asBytes();
						method_data.resize(4);
						std::vector<char> meth_vec_temp(method_data.begin(), method_data.end());
						std::string msg_head = real_trx.get_object()["input"].as_string().substr(0, 10);
						if ((msg_head == "0x" + erc::to_hex(meth_vec_temp)) 
							&& real_trx.get_object()["input"].as_string().size() > (2 + 8 + 7 * 64)
							&& real_trx.get_object().contains("call_contract"))
						{
							unsigned int nDeplength = 0;
							auto prefix = real_trx.get_object()["input"].as_string().substr(2 + 8 + 64 * 7);
							auto prefix_size = erc::ConvertPre(16, 10, erc::UnFillZero(prefix.substr(0, 64), false));
							auto msg_prefix = prefix.substr(64, fc::to_int64(prefix_size) * 2);
							std::vector<char> temp2;
							bool b_converse_x = erc::from_hex(msg_prefix.data(), temp2, msg_prefix.size(), nDeplength);
							FC_ASSERT(b_converse_x);
							std::string sMsg_prefix(temp2.begin(), temp2.end());
							hdtx.trx_id += '|'+real_trx.get_object()["call_contract"].as_string() + '|' + sMsg_prefix;
						}
					}					
					hdtx.from_account = real_trx.get_object()["from_account"].as_string();
					hdtx.asset_symbol = chain_type;
					hdtx.amount = real_trx.get_object()["amount"].as_string();
					hdtx.block_num = real_trx.get_object()["blockNum"].as_int64();
					auto input = real_trx.get_object()["input"].as_string();
					hdtx.to_account = real_trx.get_object()["to_account"].as_string();
					//if (input != "0x0"){
					hdtx.to_account += '|'+real_trx.get_object()["input"].as_string();
					//}
					if (real_trx.get_object().contains("index")){
						hdtx.to_account += '|' + real_trx.get_object()["index"].as_string();
					}
				}
				else if (trx.contains("change_signer")) {
					std::vector<char> temp;
					unsigned int nDeplength = 0;
					std::string eth_trx = trx["change_signer"].as_string();
					bool b_converse = erc::from_hex(eth_trx.data(), temp, eth_trx.size(), nDeplength);
					FC_ASSERT(b_converse);
					dev::bytes trx_temp(temp.begin(), temp.end());
					dev::eth::TransactionBase trx_base(trx_temp, dev::eth::CheckTransaction::None);
					hdtx.from_account = trx_base.from().hex();
					auto without_sign_tx = trx_base.rlp(dev::eth::WithoutSignature);
					std::string input_trx(without_sign_tx.begin(), without_sign_tx.end());
					auto input_temp = trx_base.data();
					std::vector<char> vector_input(input_temp.begin(), input_temp.end());
					auto hex_temp = erc::to_hex(vector_input.data(), vector_input.size());
					std::string input = "0x" + hex_temp;
					hdtx.to_account = trx_base.to().hex() + '|' + input;
					hdtx.asset_symbol = chain_type;
					hdtx.amount = trx_base.value().str();

				}
				else if (trx.contains("get_with_sign")) {
					std::vector<char> temp;
					unsigned int nDeplength = 0;
					std::string eth_trx = trx["get_with_sign"].as_string();
					bool b_converse = erc::from_hex(eth_trx.data(), temp, eth_trx.size(), nDeplength);
					FC_ASSERT(b_converse);
					dev::bytes trx_temp(temp.begin(), temp.end());
					dev::eth::TransactionBase trx_base(trx_temp, dev::eth::CheckTransaction::None);
					hdtx.from_account = trx_base.from().hex();
					hdtx.to_account = trx_base.to().hex();
					auto input_temp = trx_base.data();
					std::vector<char> vector_input(input_temp.begin(), input_temp.end());
					auto hex_temp = erc::to_hex(vector_input.data(), vector_input.size());
					std::string input = "0x" + hex_temp;
					if (input != "0x0") {
						hdtx.to_account += '|' + input;
					}
					//auto without_sign_tx = trx_base.rlp(dev::eth::WithoutSignature);
					//std::string input_trx(without_sign_tx.begin(), without_sign_tx.end());
					//hdtx.to_account = to_hex(input_trx.data(), input_trx.size());
					hdtx.asset_symbol = chain_type;
					hdtx.amount = trx_base.value().str();
					auto bin = trx_base.sha3();
					std::vector<char> vectorBin(bin.begin(), bin.end());
					hdtx.trx_id = "0x"+ erc::to_hex(vectorBin.data(),vectorBin.size());
				}
				else if (trx.contains("get_sign_final_trx_id")) {
					std::vector<char> temp;
					unsigned int nDeplength = 0;
					std::string eth_trx = trx["get_sign_final_trx_id"].as_string();
					bool b_converse = erc::from_hex(eth_trx.data(), temp, eth_trx.size(), nDeplength);
					FC_ASSERT(b_converse);
					dev::bytes trx_temp(temp.begin(), temp.end());
					dev::eth::TransactionBase trx_base(trx_temp, dev::eth::CheckTransaction::None);
					hdtx.from_account = trx_base.from().hex();
					hdtx.to_account = trx_base.to().hex();
					auto input_temp = trx_base.data();
					std::vector<char> vector_input(input_temp.begin(), input_temp.end());
					auto hex_temp = erc::to_hex(vector_input.data(), vector_input.size());
					auto prefix = hex_temp.substr(8 + 64 * 7);
					auto prefix_size = erc::ConvertPre(16, 10, erc::UnFillZero(prefix.substr(0, 64), false));
					auto msg_prefix = prefix.substr(64, fc::to_int64(prefix_size) * 2);
					std::vector<char> temp2;
					bool b_converse_x = erc::from_hex(msg_prefix.data(), temp2, msg_prefix.size(), nDeplength);
					FC_ASSERT(b_converse_x);
					std::string sMsg_prefix(temp2.begin(), temp2.end());
					/*
					td::string uprefix_size = FillZero(ConvertPre(10, 16, fc::to_string(uprefix.size())), false);
					std::string uprefix_array;
					for (int i = 0; i <= (uprefix.size() / 64); i++)
					{
						std::string temp = uprefix.substr(i * 64, 64);
						uprefix_array += FillZero(to_hex(temp.data(), temp.size()));
					}
					return uprefix_size + uprefix_array;*/

					std::string input = "0x" + hex_temp;
					//if (input != "0x0") {
					hdtx.to_account += '|' + input;
					//}
					//auto without_sign_tx = trx_base.rlp(dev::eth::WithoutSignature);
					//std::string input_trx(without_sign_tx.begin(), without_sign_tx.end());
					//hdtx.to_account = to_hex(input_trx.data(), input_trx.size());
					hdtx.asset_symbol = chain_type;
					hdtx.amount = trx_base.value().str();
					auto bin = trx_base.sha3();
					std::vector<char> vectorBin(bin.begin(), bin.end());
					hdtx.trx_id = "0x" + erc::to_hex(vectorBin.data(), vectorBin.size()) + "|0x" + trx_base.to().hex() + '|' + sMsg_prefix;
					//hdtx.trx_id = "0x" + trx_base.to().hex() + '|' + sMsg_prefix;
				}
				return hdtx;
			}
			FC_CAPTURE_AND_RETHROW((trx));
			return hdtx;
		}

		void crosschain_interface_erc::broadcast_transaction(const fc::variant_object &trx)
		{
			try {
				std::ostringstream req_body;
				req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Trans.broadcastTrx\" ,\
				\"params\" : {\"chainId\":\""<<chain_type<<"\" ,\"trx\": " << "\"" << trx["trx"].as_string() << "\"" << "}}";
				fc::http::connection_sync conn;

				connect_midware(conn);
				//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
				auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
				if (response.status == fc::http::reply::OK)
				{
					auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
					auto result = resp.get_object();
					if (result.contains("result"))
					{
						auto data_obj = result["result"].get_object();
						if (data_obj.contains("data"))
						{
							auto hex = data_obj["data"].as_string();
						}
						else {
							std::cout << std::string(response.body.begin(), response.body.end()) << std::endl;
						}
					}
				}
			}FC_CAPTURE_AND_LOG((trx));
		}

		std::vector<fc::variant_object> crosschain_interface_erc::query_account_balance(const std::string &account)
		{
			return std::vector<fc::variant_object>();
		}

		std::vector<fc::variant_object> crosschain_interface_erc::transaction_history(std::string symbol, const std::string &user_account, uint32_t start_block, uint32_t limit, uint32_t& end_block_num)
		{
			std::vector<fc::variant_object> return_value;
			std::string local_symbol = chain_type;
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Transaction.Deposit.History\" ,\
				\"params\" : {\"chainId\":\"" << local_symbol << "\",\"account\": \"\" ,\"limit\": 0 ,\"blockNum\": " << start_block << "}}";
			fc::http::connection_sync conn;
			connect_midware(conn);
			//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
				//std::cout << std::string(response.body.begin(), response.body.end());
				auto result = resp.get_object();
				if (result.contains("result"))
				{
					end_block_num = result["result"].get_object()["blockNum"].as_uint64();
					for (auto one_data : result["result"].get_object()["data"].get_array())
					{
						//std::cout << one_data.get_object()["txid"].as_string();
						return_value.push_back(one_data.get_object());
					}
				}
			}
			std::ostringstream req_body1;
			req_body1 << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Transaction.Withdraw.History\" ,\
				\"params\" : {\"chainId\":\"" << local_symbol << "\",\"account\": \"\" ,\"limit\": 0 ,\"blockNum\": " << start_block << "}}";
			fc::http::connection_sync conn1;

			connect_midware(conn1);
			//conn1.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response1 = conn1.request(_rpc_method, _rpc_url, req_body1.str(), _rpc_headers);
			if (response1.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response1.body.begin(), response1.body.end()));
				//std::cout << std::string(response.body.begin(), response.body.end());
				auto result = resp.get_object();
				if (result.contains("result"))
				{
					end_block_num = std::max(uint32_t(result["result"].get_object()["blockNum"].as_uint64()), end_block_num);
					for (auto one_data : result["result"].get_object()["data"].get_array())
					{
						//std::cout << one_data.get_object()["txid"].as_string();
						return_value.push_back(one_data.get_object());
					}
				}
			}
			std::ostringstream req_body2;
			req_body2 << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Transaction.GuardCall.History\" ,\
				\"params\" : {\"chainId\":\"" << local_symbol << "\",\"account\": \"\" ,\"limit\": 0 ,\"blockNum\": " << start_block << "}}";
			fc::http::connection_sync conn2;

			connect_midware(conn2);
			//conn2.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response2 = conn2.request(_rpc_method, _rpc_url, req_body2.str(), _rpc_headers);
			if (response2.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response2.body.begin(), response2.body.end()));
				//std::cout << std::string(response.body.begin(), response.body.end());
				auto result = resp.get_object();
				if (result.contains("result"))
				{
					end_block_num = std::max(uint32_t(result["result"].get_object()["blockNum"].as_uint64()), end_block_num);
					for (auto one_data : result["result"].get_object()["data"].get_array())
					{
						//std::cout << one_data.get_object()["txid"].as_string();
						return_value.push_back(one_data.get_object());
					}
				}
			}

			return return_value;
		}

		std::string crosschain_interface_erc::export_private_key(std::string &account, std::string &encrypt_passprase)
		{
			std::ostringstream req_body;
			req_body << "{ \"id\": 1, \"method\": \"dumpprivkey\", \"params\": [\""
				<< account << "\"]}";
			fc::http::connection_sync conn;
			connect_midware(conn);
			//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);
			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end())).as<fc::mutable_variant_object>();
				return resp["result"].as_string();
			}
			else
				FC_THROW(account);
		}

		std::string crosschain_interface_erc::import_private_key(std::string &account, std::string &encrypt_passprase)
		{
			return std::string();
		}

		std::string crosschain_interface_erc::backup_wallet(std::string &wallet_name, std::string &encrypt_passprase)
		{
			return std::string();
		}

		std::string crosschain_interface_erc::recover_wallet(std::string &wallet_name, std::string &encrypt_passprase)
		{
			return std::string();
		}
		std::vector<fc::variant_object> crosschain_interface_erc::transaction_history_all(std::vector<fc::mutable_variant_object> mul_param_obj) {
			std::vector<fc::variant_object> return_value;
			std::ostringstream req_body;
			req_body << "{ \"jsonrpc\": \"2.0\", \
                \"id\" : \"45\", \
				\"method\" : \"Zchain.Transaction.All.History\" ,\
				\"params\" : {\"param\":[";
			for (int i = 0; i < mul_param_obj.size(); ++i)
			{
				try
				{
					std::string chainId = mul_param_obj[i]["chainId"].as_string();
					std::string account = mul_param_obj[i]["account"].as_string();
					uint64_t blockNum = mul_param_obj[i]["blockNum"].as_uint64();
					int32_t limit = mul_param_obj[i]["limit"].as_uint64();
					req_body << "{\"chainId\":\"" << chainId << "\",";
					req_body << "\"account\":\"" << account << "\",";
					req_body << "\"blockNum\":" << blockNum << ",";
					req_body << "\"limit\":" << limit;
					if (i < mul_param_obj.size() - 1)
					{
						req_body << "},";
					}

				}
				catch (...)
				{
					if (mul_param_obj[i].find("chainId") != mul_param_obj[i].end())
					{
						std::cout << "this plugin error" << mul_param_obj[i]["chainId"].as_string() << std::endl;
					}
					else {
						std::cout << "no chainId found[" << i << "]" << std::endl;
					}
					continue;
				}
			}
			req_body << "}]}}";
			fc::http::connection_sync conn;
			connect_midware(conn);
			//conn.connect_to(fc::ip::endpoint(fc::ip::address(_config["ip"].as_string()), _config["port"].as_uint64()));
			std::cout << req_body.str() << std::endl;
			auto response = conn.request(_rpc_method, _rpc_url, req_body.str(), _rpc_headers);

			if (response.status == fc::http::reply::OK)
			{
				auto resp = fc::json::from_string(std::string(response.body.begin(), response.body.end()));
				//std::cout << std::string(response.body.begin(), response.body.end());
				auto result = resp.get_object();
				if (result.contains("result"))
				{
					auto pending_trxs = result["result"].get_array();
					for (auto one_data : pending_trxs)
					{
						return_value.push_back(one_data.get_object());
					}
				}
			}
			return return_value;
		}
	}
}
